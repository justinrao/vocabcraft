<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VocabCraft - Learn Vocabulary with Minecraft</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            font-family: 'VT323', monospace;
            background-color: #87CEEB;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-image: url('https://raw.githubusercontent.com/misode/mcmeta/master/assets/minecraft/textures/block/grass_block_side.png');
            background-size: 64px 64px;
            image-rendering: pixelated;
        }

        h1 {
            color: #fff;
            text-shadow: 2px 2px #3f3f3f;
            font-size: 3em;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .game-container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .quiz-section {
            display: none;
            /* Hide quiz section initially */
            background-color: #8B4513;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            width: 400px;
            border: 4px solid #5c2e0a;
            image-rendering: pixelated;
        }

        .building-section {
            background-color: #5c2e0a;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            width: 600px;
            height: 400px;
            position: relative;
            border: 4px solid #3d1f07;
            image-rendering: pixelated;
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.2) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.2) 1px, transparent 1px);
            background-size: 40px 40px;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .question {
            color: white;
            font-size: 1.4em;
            margin-bottom: 20px;
            text-shadow: 2px 2px #3f3f3f;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option {
            background-color: #A0522D;
            color: white;
            padding: 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1.2em;
            text-shadow: 1px 1px #3f3f3f;
            border: 2px solid #5c2e0a;
        }

        .option:hover {
            background-color: #8B4513;
            transform: scale(1.02);
        }

        .block {
            width: 40px;
            height: 40px;
            position: absolute;
            cursor: move;
            image-rendering: pixelated;
            border: 1px solid rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .block.mining {
            animation: mining 0.5s ease-in-out;
        }

        @keyframes mining {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(0.8);
            }

            100% {
                transform: scale(1);
            }
        }

        .score {
            color: white;
            font-size: 1.4em;
            margin-bottom: 20px;
            text-shadow: 2px 2px #3f3f3f;
        }

        .block-palette,
        .block-palette-container,
        .block-palette-item,
        .block-count {
            display: none !important;
        }

        .building-section.drag-over {
            background-color: #4a2510;
        }

        .character {
            display: none;
            /* Hide by default */
            width: 40px;
            height: 40px;
            position: absolute;
            transition: all 0.1s ease;
            z-index: 1000;
        }

        .character-head {
            width: 20px;
            height: 20px;
            background-color: #FFD700;
            position: absolute;
            top: 0;
            left: 10px;
            border: 2px solid #000;
        }

        .character-body {
            width: 20px;
            height: 20px;
            background-color: #3B5998;
            position: absolute;
            top: 20px;
            left: 10px;
            border: 2px solid #000;
        }

        .character-arm {
            width: 8px;
            height: 20px;
            background-color: #3B5998;
            position: absolute;
            top: 20px;
            border: 2px solid #000;
        }

        .character-arm.left {
            left: 2px;
        }

        .character-arm.right {
            right: 2px;
        }

        .character-leg {
            width: 8px;
            height: 20px;
            background-color: #2B3F6B;
            position: absolute;
            bottom: 0;
            border: 2px solid #000;
        }

        .character-leg.left {
            left: 10px;
        }

        .character-leg.right {
            right: 10px;
        }

        .character.facing-left .character-arm.left {
            transform: rotate(-30deg);
            transform-origin: top center;
        }

        .character.facing-left .character-arm.right {
            transform: rotate(30deg);
            transform-origin: top center;
        }

        .character.facing-right .character-arm.left {
            transform: rotate(30deg);
            transform-origin: top center;
        }

        .character.facing-right .character-arm.right {
            transform: rotate(-30deg);
            transform-origin: top center;
        }

        .character.facing-back .character-arm.left {
            transform: rotate(-15deg);
            transform-origin: top center;
        }

        .character.facing-back .character-arm.right {
            transform: rotate(15deg);
            transform-origin: top center;
        }

        .character-bag {
            width: 16px;
            height: 16px;
            background-color: #8B4513;
            position: absolute;
            bottom: 0;
            left: 12px;
            border: 2px solid #000;
            z-index: 999;
        }

        .character-bag::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: #A0522D;
            top: 4px;
            left: 4px;
            border: 1px solid #000;
        }

        .inventory {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 1.2em;
            text-shadow: 1px 1px #000;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .inventory-selector {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            display: none;
            /* Hide by default */
            gap: 10px;
            z-index: 1000;
            border: 2px solid #5c2e0a;
            min-height: 80px;
        }

        .inventory-slot {
            width: 50px;
            height: 50px;
            border: 2px solid #fff;
            border-radius: 5px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            background-size: cover;
            image-rendering: pixelated;
            margin: 15px 5px;
        }

        .inventory-slot:hover {
            transform: scale(1.1);
        }

        .inventory-slot.selected {
            border-color: #ffd700;
            box-shadow: 0 0 10px #ffd700;
        }

        .inventory-slot .block-count {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #ffd700;
            color: black;
            padding: 2px 5px;
            border-radius: 50%;
            font-size: 1em;
            font-weight: bold;
            min-width: 22px;
            height: 22px;
            text-align: center;
            border: 2px solid #000;
            z-index: 1001;
            display: block !important;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.4);
            transition: all 0.2s ease-out;
        }

        .inventory-slot .block-count.pulse {
            animation: countPulse 0.5s ease-out;
        }

        .inventory-slot .block-name {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 1em;
            white-space: nowrap;
            z-index: 1001;
        }

        .inventory-slot.empty {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .inventory-slot.empty .block-count {
            background-color: #ff4444;
        }

        .profile-name-display {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 1.2em;
            z-index: 1000;
        }

        .profile-container {
            display: block;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            color: white;
            text-align: center;
            max-width: 600px;
            margin: 20px auto;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001;
        }

        .profile-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .profile-item {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .profile-item:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.02);
        }

        .profile-item .profile-info {
            text-align: left;
        }

        .profile-item .profile-name {
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .profile-item .profile-stats {
            font-size: 0.9em;
            color: #ccc;
        }

        .profile-item .delete-profile {
            background-color: #ff4444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .profile-item .delete-profile:hover {
            opacity: 1;
        }

        .new-profile-form {
            margin-top: 20px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .new-profile-form input {
            padding: 10px;
            margin: 10px 0;
            width: 200px;
            border: none;
            border-radius: 5px;
            font-family: 'VT323', monospace;
            font-size: 1.1em;
        }

        .new-profile-form button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1.1em;
            margin-top: 10px;
        }

        .new-profile-form button:hover {
            background-color: #45a049;
        }

        .save-indicator {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .save-indicator.visible {
            opacity: 1;
        }

        .game-controls {
            position: fixed;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .game-control-button {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1.1em;
            transition: all 0.2s ease;
        }

        .game-control-button:hover {
            background-color: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }

        .game-control-button.save {
            background-color: rgba(76, 175, 80, 0.7);
        }

        .game-control-button.save:hover {
            background-color: rgba(76, 175, 80, 0.9);
        }

        .game-control-button.exit {
            background-color: rgba(244, 67, 54, 0.7);
        }

        .game-control-button.exit:hover {
            background-color: rgba(244, 67, 54, 0.9);
        }

        .game-control-button.admin {
            background-color: rgba(255, 193, 7, 0.7);
        }

        .game-control-button.admin:hover {
            background-color: rgba(255, 193, 7, 0.9);
        }

        @keyframes blockAdded {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .block-added-animation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 1000;
            animation: blockAdded 0.5s ease-out forwards;
        }

        @keyframes countPulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(2);
                color: #000;
                background-color: #ffd700;
                box-shadow: 0 0 15px #ffd700;
            }

            100% {
                transform: scale(1);
            }
        }
    </style>
</head>

<body>
    <h1>VocabCraft</h1>

    <div class="game-container" id="gameContainer">
        <div class="game-controls">
            <button class="game-control-button admin" onclick="showAdminStats()">Admin</button>
            <button class="game-control-button exit" onclick="saveAndExit()">Exit</button>
        </div>
        <div class="profile-name-display" id="profileNameDisplay"></div>
        <div class="quiz-section" id="quizSection">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="question" id="question"></div>
            <div class="options" id="options"></div>
        </div>
        <div class="building-section" id="buildingArea">
            <div class="inventory-selector" id="inventorySelector"></div>
        </div>
    </div>

    <div class="profile-container" id="profileContainer">
        <h2>Select or Create a Profile</h2>
        <div class="profile-list" id="profileList"></div>
        <div class="new-profile-form">
            <input type="text" id="newProfileName" placeholder="Enter profile name" maxlength="20">
            <button onclick="createNewProfile()">Create New Profile</button>
        </div>
    </div>

    <div class="save-indicator" id="saveIndicator">Game Saved!</div>
    <div id="adminStats"
        style="display:none; background:rgba(0, 0, 0, 0.9); color:#fff; padding:20px; border-radius:10px; max-width:90vw; max-height:80vh; overflow:auto; position:fixed; top:50px; left:50%; transform:translateX(-50%); z-index:2000; font-family: 'VT323', monospace;">
    </div>

    <script>
        // Block textures
        const blockTextures = {
            'dirt': 'https://raw.githubusercontent.com/misode/mcmeta/master/assets/minecraft/textures/block/dirt.png',
            'stone': 'https://raw.githubusercontent.com/misode/mcmeta/master/assets/minecraft/textures/block/stone.png',
            'wood': 'https://raw.githubusercontent.com/misode/mcmeta/master/assets/minecraft/textures/block/oak_planks.png',
            'glass': 'https://raw.githubusercontent.com/misode/mcmeta/master/assets/minecraft/textures/block/glass.png'
        };

        // Profile Management
        class ProfileManager {
            constructor() {
                console.log('Initializing ProfileManager');
                this.profiles = this.loadProfiles();
                this.currentProfile = null;
                this.renderProfileList();
            }

            loadProfiles() {
                const profiles = localStorage.getItem('vocabcraft_profiles');
                return profiles ? JSON.parse(profiles) : {};
            }

            saveProfiles() {
                localStorage.setItem('vocabcraft_profiles', JSON.stringify(this.profiles));
            }

            createProfile(name) {
                if (this.profiles[name]) {
                    return false; // Profile already exists
                }
                this.profiles[name] = {
                    score: 0,
                    currentQuestion: 0,
                    blockCounts: {
                        dirt: 0,
                        stone: 0,
                        wood: 0,
                        glass: 0
                    },
                    blocks: [],
                    characterPosition: {
                        x: 280,
                        y: 180
                    },
                    lastSaved: new Date().toISOString(),
                    questionStats: {} // { [questionId]: { correct: 0, incorrect: 0 } }
                };
                this.saveProfiles();
                this.renderProfileList();
                return true;
            }

            deleteProfile(name) {
                if (confirm(`Are you sure you want to delete profile "${name}"?`)) {
                    delete this.profiles[name];
                    this.saveProfiles();
                    this.renderProfileList();
                }
            }

            loadProfile(name) {
                this.currentProfile = name;
                return this.profiles[name];
            }

            saveProfile(gameState) {
                if (!this.currentProfile) return;

                this.profiles[this.currentProfile] = {
                    ...gameState,
                    lastSaved: new Date().toISOString()
                };

                this.saveProfiles();
                this.showSaveIndicator();
            }

            renderProfileList() {
                const profileList = document.getElementById('profileList');
                if (!profileList) {
                    console.error('Profile list element not found');
                    return;
                }

                profileList.innerHTML = '';

                Object.entries(this.profiles).forEach(([name, data]) => {
                    const profileItem = document.createElement('div');
                    profileItem.className = 'profile-item';

                    const profileInfo = document.createElement('div');
                    profileInfo.className = 'profile-info';

                    const profileName = document.createElement('div');
                    profileName.className = 'profile-name';
                    profileName.textContent = name;

                    const profileStats = document.createElement('div');
                    profileStats.className = 'profile-stats';
                    profileStats.textContent = `Score: ${data.score} | Last saved: ${new Date(data.lastSaved).toLocaleString()}`;

                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'delete-profile';
                    deleteButton.textContent = 'Delete';
                    deleteButton.onclick = (e) => {
                        e.stopPropagation();
                        this.deleteProfile(name);
                    };

                    profileInfo.appendChild(profileName);
                    profileInfo.appendChild(profileStats);
                    profileItem.appendChild(profileInfo);
                    profileItem.appendChild(deleteButton);

                    profileItem.onclick = () => this.startGame(name);
                    profileList.appendChild(profileItem);
                });
            }

            showSaveIndicator() {
                const indicator = document.getElementById('saveIndicator');
                indicator.classList.add('visible');
                setTimeout(() => {
                    indicator.classList.remove('visible');
                }, 2000);
            }

            startGame(profileName) {
                console.log('Starting game for profile:', profileName);
                const gameState = this.loadProfile(profileName);
                if (!gameState) {
                    console.error('No game state found for profile:', profileName);
                    return;
                }

                console.log('Loaded game state:', gameState);

                // Get all required elements
                const profileContainer = document.getElementById('profileContainer');
                const quizSection = document.getElementById('quizSection');
                const inventorySelector = document.getElementById('inventorySelector');
                const buildingArea = document.getElementById('buildingArea');
                const profileNameDisplay = document.getElementById('profileNameDisplay');

                // Verify all required elements exist
                if (!profileContainer || !quizSection || !inventorySelector || !buildingArea || !profileNameDisplay) {
                    console.error('Required UI elements not found:', {
                        profileContainer: !!profileContainer,
                        quizSection: !!quizSection,
                        inventorySelector: !!inventorySelector,
                        buildingArea: !!buildingArea,
                        profileNameDisplay: !!profileNameDisplay
                    });
                    return;
                }

                // Show loading state
                const loadingMessage = document.createElement('div');
                loadingMessage.style.position = 'fixed';
                loadingMessage.style.top = '50%';
                loadingMessage.style.left = '50%';
                loadingMessage.style.transform = 'translate(-50%, -50%)';
                loadingMessage.style.padding = '20px';
                loadingMessage.style.background = 'rgba(0, 0, 0, 0.8)';
                loadingMessage.style.color = 'white';
                loadingMessage.style.borderRadius = '10px';
                loadingMessage.style.zIndex = '9999';
                loadingMessage.textContent = 'Loading vocabulary...';
                document.body.appendChild(loadingMessage);

                // Hide profile UI
                profileContainer.style.display = 'none';

                // Show game UI elements
                quizSection.style.display = 'block';
                inventorySelector.style.display = 'flex';

                // Clear any existing game state
                this.cleanupGameState();

                // Initialize new game
                console.log('Creating new game instance');
                window.game = new VocabCraft(this, profileName);

                // Remove loading message when vocabulary is loaded
                window.game.loadVocabulary().then(() => {
                    document.body.removeChild(loadingMessage);
                    // Load game state
                    console.log('Loading game state');
                    window.game.loadGame(gameState);
                }).catch(error => {
                    console.error('Error loading vocabulary:', error);
                    loadingMessage.textContent = 'Error loading vocabulary. Please refresh the page.';
                    loadingMessage.style.background = 'rgba(255, 0, 0, 0.8)';
                });
            }

            cleanupGameState() {
                console.log('Cleaning up game state');

                // Get all required elements
                const buildingArea = document.getElementById('buildingArea');
                const quizSection = document.getElementById('quizSection');
                const inventorySelector = document.getElementById('inventorySelector');

                // Clear building area if it exists
                if (buildingArea) {
                    buildingArea.innerHTML = '<div class="inventory-selector" id="inventorySelector"></div>';
                }

                // Remove character if exists
                if (window.game && window.game.character && window.game.character.element) {
                    window.game.character.element.remove();
                }

                // Hide game UI elements if they exist
                if (quizSection) {
                    quizSection.style.display = 'none';
                }
                if (inventorySelector) {
                    inventorySelector.style.display = 'none';
                }

                // Clear game instance
                window.game = null;
            }

            exitToProfile() {
                if (window.game) {
                    const gameState = window.game.saveGame();
                    this.saveProfile(gameState);
                }

                // Show profile UI
                document.getElementById('profileContainer').style.display = 'block';
                document.getElementById('quizSection').style.display = 'none';
                document.getElementById('inventorySelector').style.display = 'none';

                // Clean up game state
                this.cleanupGameState();

                // Update profile list
                this.renderProfileList();
            }
        }

        // Game class update
        class VocabCraft {
            constructor(profileManager, profileName) {
                console.log('Initializing VocabCraft with profile:', profileName);
                this.profileManager = profileManager;
                this.profileName = profileName;
                this.vocabulary = [];
                this.currentQuestion = 0;
                this.score = 0;
                this.blocks = [];
                this.blockCounts = {
                    dirt: 0,
                    stone: 0,
                    wood: 0,
                    glass: 0
                };
                this.selectedBlockType = null;

                // Load vocabulary before initializing the game
                this.loadVocabulary().then(() => {
                    // Initialize game components
                    this.initGame();
                    this.setupAutoSave();
                });
            }

            async loadVocabulary() {
                try {
                    // Try to load from the same directory first (for local development)
                    const response = await fetch('./vocabulary.json');
                    if (!response.ok) {
                        // If that fails, try loading from the GitHub Pages URL
                        const githubResponse = await fetch('https://justinrao.github.io/vocabcraft/vocabulary.json');
                        if (!githubResponse.ok) {
                            throw new Error('Failed to load vocabulary');
                        }
                        const data = await githubResponse.json();
                        this.vocabulary = data.vocabulary;
                    } else {
                        const data = await response.json();
                        this.vocabulary = data.vocabulary;
                    }
                    console.log('Vocabulary loaded successfully:', this.vocabulary);
                } catch (error) {
                    console.error('Error loading vocabulary:', error);
                    // Fallback to empty vocabulary
                    this.vocabulary = [];
                }
            }

            initGame() {
                console.log('Initializing game components');
                try {
                    // Get all required elements
                    const profileNameDisplay = document.getElementById('profileNameDisplay');
                    const quizSection = document.getElementById('quizSection');
                    const inventorySelector = document.getElementById('inventorySelector');

                    // Verify elements exist
                    if (!profileNameDisplay || !quizSection || !inventorySelector) {
                        throw new Error('Required UI elements not found');
                    }

                    // Set up UI elements
                    profileNameDisplay.textContent = `Profile: ${this.profileName}`;
                    quizSection.style.display = 'block';
                    inventorySelector.style.display = 'flex';

                    // Create character
                    console.log('Creating character');
                    this.character = new Character(this);
                    if (this.character && this.character.element) {
                        this.character.element.style.display = 'block';
                    }

                    // Create inventory
                    console.log('Creating inventory');
                    this.createInventorySelector();

                    // Show first question
                    console.log('Showing first question');
                    this.showQuestion();

                    console.log('Game initialization complete');
                } catch (error) {
                    console.error('Error during game initialization:', error);
                }
            }

            setupAutoSave() {
                // Auto-save every 30 seconds
                setInterval(() => {
                    this.saveGame();
                }, 30000);

                // Save when window is closed
                window.addEventListener('beforeunload', () => {
                    this.saveGame();
                });
            }

            loadGame(gameState) {
                console.log('Loading game state:', gameState);
                if (!gameState) {
                    console.error('No game state provided');
                    return;
                }

                this.score = gameState.score || 0;
                // Use questionId if available, otherwise fallback to index
                if (gameState.currentQuestionId) {
                    const idx = this.vocabulary.findIndex(q => q.id === gameState.currentQuestionId);
                    this.currentQuestion = idx !== -1 ? idx : 0;
                } else {
                    this.currentQuestion = gameState.currentQuestion || 0;
                }
                if (this.currentQuestion >= this.vocabulary.length) {
                    this.currentQuestion = 0;
                }
                // Initialize block counts
                this.blockCounts = {
                    dirt: 0,
                    stone: 0,
                    wood: 0,
                    glass: 0
                };

                // Clear existing blocks
                const buildingArea = document.getElementById('buildingArea');
                this.blocks.forEach(block => {
                    if (block.parentNode === buildingArea) {
                        block.remove();
                    }
                });
                this.blocks = [];

                // Restore blocks and count them
                if (gameState.blocks && gameState.blocks.length > 0) {
                    console.log('Restoring blocks:', gameState.blocks.length);
                    gameState.blocks.forEach(blockData => {
                        const block = document.createElement('div');
                        block.className = 'block';
                        Object.assign(block.style, getBlockStyle(blockData.type));
                        block.style.left = blockData.x + 'px';
                        block.style.top = blockData.y + 'px';
                        buildingArea.appendChild(block);
                        this.blocks.push(block);
                        makeBlockDraggable(block);
                        console.log('Restored block:', blockData);
                    });
                }

                // Restore character position if available
                if (gameState.characterPosition && this.character) {
                    this.character.posX = gameState.characterPosition.x;
                    this.character.posY = gameState.characterPosition.y;
                    this.character.element.style.left = this.character.posX + 'px';
                    this.character.element.style.top = this.character.posY + 'px';
                }

                // Show current question
                this.showQuestion();

                // Update inventory display
                this.createInventorySelector();

                // Ensure building area is visible
                buildingArea.style.display = 'block';
            }

            saveGame() {
                // Calculate current block counts from placed blocks
                const currentBlockCounts = {
                    dirt: 0,
                    stone: 0,
                    wood: 0,
                    glass: 0
                };

                // Count blocks by type
                this.blocks.forEach(block => {
                    const type = this.character.getBlockType(block);
                    currentBlockCounts[type]++;
                });

                // Add any remaining blocks in inventory
                Object.keys(this.blockCounts).forEach(type => {
                    currentBlockCounts[type] += this.blockCounts[type];
                });

                const gameState = {
                    score: this.score,
                    currentQuestionId: this.vocabulary[this.currentQuestion]?.id || null,
                    currentQuestion: this.currentQuestion,
                    blockCounts: currentBlockCounts,
                    blocks: this.blocks.map(block => ({
                        type: this.character.getBlockType(block),
                        x: parseInt(block.style.left),
                        y: parseInt(block.style.top)
                    })),
                    characterPosition: {
                        x: this.character.posX,
                        y: this.character.posY
                    },
                    questionStats: this.profileManager.profiles[this.profileManager.currentProfile]?.questionStats || {}
                };

                console.log('Saving game state:', gameState);
                this.profileManager.saveProfile(gameState);
                return gameState;
            }

            showQuestion() {
                console.log('Showing question:', this.currentQuestion);
                try {
                    const question = this.vocabulary[this.currentQuestion];
                    if (!question) {
                        throw new Error(`No question found for index: ${this.currentQuestion}`);
                    }

                    const questionElement = document.getElementById('question');
                    const optionsContainer = document.getElementById('options');

                    if (!questionElement || !optionsContainer) {
                        throw new Error('Question elements not found');
                    }

                    questionElement.textContent =
                        `What is the meaning of "${question.word}"?\n\nExample: ${question.example}`;

                    optionsContainer.innerHTML = '';

                    question.options.forEach((option) => {
                        const button = document.createElement('button');
                        button.className = 'option';
                        button.textContent = option;
                        button.onclick = () => this.checkAnswer(option);
                        optionsContainer.appendChild(button);
                    });

                    console.log('Question displayed successfully');
                } catch (error) {
                    console.error('Error showing question:', error);
                }
            }

            checkAnswer(selectedAnswer) {
                const question = this.vocabulary[this.currentQuestion];
                if (!question) {
                    console.error('No question found for index:', this.currentQuestion);
                    return;
                }
                const optionsContainer = document.getElementById('options');
                const buttons = optionsContainer.getElementsByClassName('option');
                // Track stats
                const profile = this.profileManager.profiles[this.profileManager.currentProfile];
                if (profile) {
                    if (!profile.questionStats) profile.questionStats = {};
                    if (!profile.questionStats[question.id]) profile.questionStats[question.id] = { correct: 0, incorrect: 0 };
                }
                let wasCorrect = false;
                Array.from(buttons).forEach(button => {
                    button.disabled = true;
                    if (button.textContent === selectedAnswer) {
                        if (selectedAnswer === question.meaning) {
                            button.style.backgroundColor = '#4CAF50';
                            this.score += 10;
                            document.getElementById('score').textContent = this.score;
                            this.addBonusBlock();
                            wasCorrect = true;
                        } else {
                            button.style.backgroundColor = '#f44336';
                        }
                    }
                });
                Array.from(buttons).forEach(button => {
                    if (button.textContent === question.meaning) {
                        button.style.backgroundColor = '#4CAF50';
                    }
                });
                // Update stats
                if (profile) {
                    if (wasCorrect) {
                        profile.questionStats[question.id].correct++;
                    } else {
                        profile.questionStats[question.id].incorrect++;
                    }
                    this.profileManager.saveProfile(this.saveGame());
                }
                setTimeout(() => {
                    this.currentQuestion = (this.currentQuestion + 1) % this.vocabulary.length;
                    this.showQuestion();
                }, 1500);
            }

            addBonusBlock() {
                const blockTypes = ['dirt', 'stone', 'wood', 'glass'];
                const randomType = blockTypes[Math.floor(Math.random() * blockTypes.length)];

                // Add block to inventory
                this.blockCounts[randomType]++;

                // Find the count element and animate it
                const selector = document.getElementById('inventorySelector');
                const slot = selector.querySelector(`[data-type="${randomType}"]`);
                if (slot) {
                    const countElement = slot.querySelector('.block-count');
                    if (countElement) {
                        countElement.textContent = this.blockCounts[randomType].toString();
                        countElement.classList.remove('pulse');
                        countElement.offsetHeight; // Trigger reflow
                        countElement.classList.add('pulse');
                    }
                }

                // Update all slot appearances
                this.updateBlockCounts();
            }

            createInventorySelector() {
                console.log('Creating inventory selector...');
                const selector = document.getElementById('inventorySelector');
                if (!selector) {
                    console.error('Inventory selector element not found!');
                    return;
                }
                selector.innerHTML = '';
                console.log('Current block counts:', this.blockCounts);

                const blockTypes = [
                    { type: 'dirt', name: 'Dirt' },
                    { type: 'stone', name: 'Stone' },
                    { type: 'wood', name: 'Wood' },
                    { type: 'glass', name: 'Glass' }
                ];

                blockTypes.forEach(blockInfo => {
                    const slot = document.createElement('div');
                    slot.className = 'inventory-slot';
                    slot.dataset.type = blockInfo.type;
                    Object.assign(slot.style, getBlockStyle(blockInfo.type));

                    const count = document.createElement('div');
                    count.className = 'block-count';
                    const currentCount = this.blockCounts[blockInfo.type] || 0;
                    console.log(`Creating slot for ${blockInfo.type} with count:`, currentCount);
                    count.textContent = currentCount.toString();

                    const name = document.createElement('div');
                    name.className = 'block-name';
                    name.textContent = blockInfo.name;

                    slot.appendChild(count);
                    slot.appendChild(name);
                    selector.appendChild(slot);

                    // Update slot appearance based on count
                    this.updateSlotAppearance(slot, blockInfo.type);

                    slot.addEventListener('click', () => {
                        if (this.blockCounts[blockInfo.type] > 0) {
                            this.selectBlock(slot);
                        }
                    });
                });

                // Select first available block by default
                this.selectFirstAvailableBlock();
                console.log('Inventory selector created with slots');
            }

            selectFirstAvailableBlock() {
                const selector = document.getElementById('inventorySelector');
                const slots = selector.querySelectorAll('.inventory-slot');
                
                // Find first available block
                const availableSlot = Array.from(slots).find(slot => 
                    this.blockCounts[slot.dataset.type] > 0
                );

                if (availableSlot) {
                    this.selectBlock(availableSlot);
                } else {
                    // If no blocks available, deselect all
                    this.selectedBlockType = null;
                    slots.forEach(slot => slot.classList.remove('selected'));
                }
            }

            selectBlock(slot) {
                const selector = document.getElementById('inventorySelector');
                selector.querySelectorAll('.inventory-slot').forEach(s => {
                    s.classList.remove('selected');
                });
                slot.classList.add('selected');
                this.selectedBlockType = slot.dataset.type;
            }

            updateSlotAppearance(slot, type) {
                const count = this.blockCounts[type] || 0;
                console.log(`Updating appearance for ${type}, count:`, count);
                const countElement = slot.querySelector('.block-count');
                if (countElement) {
                    console.log(`Found count element for ${type}, updating to:`, count);
                    countElement.textContent = count.toString();
                } else {
                    console.log(`No count element found for ${type}`);
                }

                if (count === 0) {
                    slot.classList.add('empty');
                    // If this was the selected block, select another available one
                    if (this.selectedBlockType === type) {
                        this.selectFirstAvailableBlock();
                    }
                } else {
                    slot.classList.remove('empty');
                }
            }

            updateBlockCounts() {
                console.log('Updating all block counts:', this.blockCounts);
                const selector = document.getElementById('inventorySelector');
                if (selector) {
                    selector.querySelectorAll('.inventory-slot').forEach(slot => {
                        const type = slot.dataset.type;
                        this.updateSlotAppearance(slot, type);
                    });
                } else {
                    console.log('Inventory selector not found');
                }
            }

            placeBlock(x, y) {
                if (this.selectedBlockType && this.blockCounts[this.selectedBlockType] > 0) {
                    const block = document.createElement('div');
                    block.className = 'block';
                    Object.assign(block.style, getBlockStyle(this.selectedBlockType));

                    const gridX = Math.floor(x / 40) * 40;
                    const gridY = Math.floor(y / 40) * 40;

                    block.style.left = gridX + 'px';
                    block.style.top = gridY + 'px';

                    const isOccupied = this.blocks.some(existingBlock => {
                        const existingX = parseInt(existingBlock.style.left);
                        const existingY = parseInt(existingBlock.style.top);
                        return existingX === gridX && existingY === gridY;
                    });

                    if (!isOccupied) {
                        document.getElementById('buildingArea').appendChild(block);
                        this.blocks.push(block);
                        this.blockCounts[this.selectedBlockType]--;
                        this.updateBlockCounts();
                        makeBlockDraggable(block);

                        block.style.opacity = '0';
                        block.style.transform = 'scale(0.5)';
                        requestAnimationFrame(() => {
                            block.style.transition = 'all 0.3s ease-out';
                            block.style.opacity = '1';
                            block.style.transform = 'scale(1)';
                        });

                        // Save state after placing block
                        this.saveGame();
                    }
                }
            }

            addBlock(type) {
                console.log(`Adding block of type ${type}, current count:`, this.blockCounts[type]);
                if (this.blockCounts[type] !== undefined) {
                    this.blockCounts[type]++;
                    console.log(`New count for ${type}:`, this.blockCounts[type]);
                    this.updateBlockCounts();
                    
                    // If this is the first block of this type, select it
                    if (this.blockCounts[type] === 1) {
                        const selector = document.getElementById('inventorySelector');
                        const slot = selector.querySelector(`[data-type="${type}"]`);
                        if (slot) {
                            this.selectBlock(slot);
                        }
                    }
                }
            }
        }

        // Character class to manage the player character
        class Character {
            constructor(game) {
                this.game = game;
                this.element = this.createCharacter();
                this.posX = 280;
                this.posY = 180;
                this.speed = 40;
                this.initControls();

                // Set initial position immediately
                this.element.style.left = this.posX + 'px';
                this.element.style.top = this.posY + 'px';
            }

            createCharacter() {
                const character = document.createElement('div');
                character.className = 'character';

                const head = document.createElement('div');
                head.className = 'character-head';

                const body = document.createElement('div');
                body.className = 'character-body';

                const leftArm = document.createElement('div');
                leftArm.className = 'character-arm left';

                const rightArm = document.createElement('div');
                rightArm.className = 'character-arm right';

                const leftLeg = document.createElement('div');
                leftLeg.className = 'character-leg left';

                const rightLeg = document.createElement('div');
                rightLeg.className = 'character-leg right';

                const bag = document.createElement('div');
                bag.className = 'character-bag';

                character.appendChild(head);
                character.appendChild(body);
                character.appendChild(leftArm);
                character.appendChild(rightArm);
                character.appendChild(leftLeg);
                character.appendChild(rightLeg);
                character.appendChild(bag);

                character.style.left = this.posX + 'px';
                character.style.top = this.posY + 'px';
                document.getElementById('buildingArea').appendChild(character);

                return character;
            }

            initControls() {
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        this.mineBlock();
                        return;
                    }

                    // Inventory controls
                    if (e.key.toLowerCase() === 'a') {
                        this.selectPreviousBlock();
                        return;
                    }
                    if (e.key.toLowerCase() === 's') {
                        this.selectNextBlock();
                        return;
                    }
                    if (e.key.toLowerCase() === 'd') {
                        this.placeBlockInFront();
                        return;
                    }

                    let newX = this.posX;
                    let newY = this.posY;
                    let direction = '';

                    switch (e.key) {
                        case 'ArrowLeft':
                            newX = Math.max(0, this.posX - this.speed);
                            direction = 'left';
                            break;
                        case 'ArrowRight':
                            newX = Math.min(document.getElementById('buildingArea').clientWidth - 40, this.posX + this.speed);
                            direction = 'right';
                            break;
                        case 'ArrowUp':
                            newY = Math.max(0, this.posY - this.speed);
                            direction = 'back';
                            break;
                        case 'ArrowDown':
                            newY = Math.min(document.getElementById('buildingArea').clientHeight - 40, this.posY + this.speed);
                            direction = 'front';
                            break;
                    }

                    if (!this.willCollide(newX, newY)) {
                        this.posX = newX;
                        this.posY = newY;
                        this.element.style.left = this.posX + 'px';
                        this.element.style.top = this.posY + 'px';

                        // Update facing direction
                        this.element.className = 'character';
                        if (direction) {
                            this.element.classList.add('facing-' + direction);
                        }
                    }
                });
            }

            selectPreviousBlock() {
                const selector = document.getElementById('inventorySelector');
                const slots = selector.querySelectorAll('.inventory-slot');
                const currentIndex = Array.from(slots).findIndex(slot => slot.classList.contains('selected'));

                let newIndex = currentIndex - 1;
                if (newIndex < 0) newIndex = slots.length - 1;

                // Find the first non-empty slot going backwards
                while (newIndex !== currentIndex) {
                    const slot = slots[newIndex];
                    const type = slot.dataset.type;
                    if (this.game.blockCounts[type] > 0) {
                        this.selectBlock(slot);
                        break;
                    }
                    newIndex = (newIndex - 1 + slots.length) % slots.length;
                }
            }

            selectNextBlock() {
                const selector = document.getElementById('inventorySelector');
                const slots = selector.querySelectorAll('.inventory-slot');
                const currentIndex = Array.from(slots).findIndex(slot => slot.classList.contains('selected'));

                let newIndex = (currentIndex + 1) % slots.length;

                // Find the first non-empty slot going forwards
                while (newIndex !== currentIndex) {
                    const slot = slots[newIndex];
                    const type = slot.dataset.type;
                    if (this.game.blockCounts[type] > 0) {
                        this.selectBlock(slot);
                        break;
                    }
                    newIndex = (newIndex + 1) % slots.length;
                }
            }

            selectBlock(slot) {
                const selector = document.getElementById('inventorySelector');
                selector.querySelectorAll('.inventory-slot').forEach(s => {
                    s.classList.remove('selected');
                });
                slot.classList.add('selected');
                this.game.selectedBlockType = slot.dataset.type;
            }

            placeBlockInFront() {
                if (!this.game.selectedBlockType || this.game.blockCounts[this.game.selectedBlockType] <= 0) {
                    return;
                }

                // Calculate position in front of character based on facing direction
                let placeX = this.posX;
                let placeY = this.posY;

                // Determine placement position based on character's facing direction
                if (this.element.classList.contains('facing-left')) {
                    placeX -= 40;
                } else if (this.element.classList.contains('facing-right')) {
                    placeX += 40;
                } else if (this.element.classList.contains('facing-back')) {
                    placeY -= 40;
                } else { // facing front (default)
                    placeY += 40;
                }

                // Snap to grid
                placeX = Math.floor(placeX / 40) * 40;
                placeY = Math.floor(placeY / 40) * 40;

                // Check if position is within bounds
                const buildingArea = document.getElementById('buildingArea');
                if (placeX < 0 || placeX > buildingArea.clientWidth - 40 ||
                    placeY < 0 || placeY > buildingArea.clientHeight - 40) {
                    return;
                }

                // Check if position is already occupied
                const isOccupied = this.game.blocks.some(block => {
                    const blockX = parseInt(block.style.left);
                    const blockY = parseInt(block.style.top);
                    return blockX === placeX && blockY === placeY;
                });

                if (!isOccupied) {
                    const block = document.createElement('div');
                    block.className = 'block';
                    Object.assign(block.style, getBlockStyle(this.game.selectedBlockType));
                    block.style.left = placeX + 'px';
                    block.style.top = placeY + 'px';

                    buildingArea.appendChild(block);
                    this.game.blocks.push(block);
                    this.game.blockCounts[this.game.selectedBlockType]--;
                    this.game.updateBlockCounts();
                    makeBlockDraggable(block);

                    // Add placement animation
                    block.style.opacity = '0';
                    block.style.transform = 'scale(0.5)';
                    requestAnimationFrame(() => {
                        block.style.transition = 'all 0.3s ease-out';
                        block.style.opacity = '1';
                        block.style.transform = 'scale(1)';
                    });
                }
            }

            willCollide(newX, newY) {
                return this.game.blocks.some(block => {
                    const blockX = parseInt(block.style.left);
                    const blockY = parseInt(block.style.top);
                    return Math.abs(blockX - newX) < 40 && Math.abs(blockY - newY) < 40;
                });
            }

            isOnBlock() {
                const characterCenterX = this.posX + 20;
                const characterCenterY = this.posY + 20;

                return this.game.blocks.some(block => {
                    const blockX = parseInt(block.style.left);
                    const blockY = parseInt(block.style.top);
                    const blockCenterX = blockX + 20;
                    const blockCenterY = blockY + 20;

                    const distanceX = Math.abs(characterCenterX - blockCenterX);
                    const distanceY = Math.abs(characterCenterY - blockCenterY);

                    return distanceX <= 60 && distanceY <= 60;
                });
            }

            getBlockType(block) {
                // Get the computed style of the block
                const style = window.getComputedStyle(block);
                const backgroundColor = style.backgroundColor;

                // Convert RGB colors to comparable format
                const normalizeColor = (color) => {
                    // Convert rgb(r, g, b) to rgb(r,g,b)
                    return color.replace(/\s/g, '').toLowerCase();
                };

                const normalizedBgColor = normalizeColor(backgroundColor);

                // Define color mappings for each block type
                const colorMappings = {
                    'rgb(139,69,19)': 'dirt',      // #8B4513
                    'rgb(128,128,128)': 'stone',   // #808080
                    'rgb(160,82,45)': 'wood',      // #A0522D
                    'rgb(173,216,230)': 'glass'    // #ADD8E6
                };

                // Check if the color matches any of our known block types
                for (const [color, type] of Object.entries(colorMappings)) {
                    if (normalizeColor(color) === normalizedBgColor) {
                        return type;
                    }
                }

                // If no match found, try to determine by background image
                const backgroundImage = style.backgroundImage;
                if (backgroundImage.includes('linear-gradient')) {
                    if (backgroundImage.includes('45deg')) {
                        if (backgroundImage.includes('173,216,230')) return 'glass';
                        if (backgroundImage.includes('139,69,19')) return 'dirt';
                        if (backgroundImage.includes('128,128,128')) return 'stone';
                    } else if (backgroundImage.includes('90deg')) {
                        return 'wood';
                    }
                }

                return 'dirt'; // Default to dirt if type can't be determined
            }

            mineBlock() {
                if (!this.isOnBlock()) return;

                const characterCenterX = this.posX + 20;
                const characterCenterY = this.posY + 20;

                let closestBlock = null;
                let minDistance = Infinity;

                this.game.blocks.forEach(block => {
                    if (block.closest('.block-palette')) return;

                    const blockX = parseInt(block.style.left);
                    const blockY = parseInt(block.style.top);
                    const blockCenterX = blockX + 20;
                    const blockCenterY = blockY + 20;

                    const distanceX = Math.abs(characterCenterX - blockCenterX);
                    const distanceY = Math.abs(characterCenterY - blockCenterY);
                    const totalDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

                    if (totalDistance < minDistance && distanceX <= 60 && distanceY <= 60) {
                        minDistance = totalDistance;
                        closestBlock = block;
                    }
                });

                if (closestBlock) {
                    const blockType = this.getBlockType(closestBlock);
                    closestBlock.classList.add('mining');
                    closestBlock.style.animation = 'mining 0.5s ease-in-out';

                    setTimeout(() => {
                        if (closestBlock.parentNode) {
                            closestBlock.remove();
                            this.game.blocks = this.game.blocks.filter(b => b !== closestBlock);
                            this.game.addBlock(blockType);
                            
                            // Save state after mining block
                            this.game.saveGame();
                        }
                    }, 500);
                }
            }

            addBlock() {
                const block = document.createElement('div');
                block.className = 'block';

                const blockTypes = ['dirt', 'stone', 'wood', 'glass'];
                const randomType = blockTypes[Math.floor(Math.random() * blockTypes.length)];
                Object.assign(block.style, getBlockStyle(randomType));

                const buildingArea = document.getElementById('buildingArea');
                const areaWidth = buildingArea.clientWidth - 40;
                const areaHeight = buildingArea.clientHeight - 40;

                let attempts = 0;
                let position;
                let isOverlapping;

                do {
                    const x = Math.floor(Math.random() * (areaWidth / 40)) * 40;
                    const y = Math.floor(Math.random() * (areaHeight / 40)) * 40;
                    position = { x, y };

                    isOverlapping = this.game.blocks.some(existingBlock => {
                        const existingX = parseInt(existingBlock.style.left);
                        const existingY = parseInt(existingBlock.style.top);
                        return existingX === x && existingY === y;
                    });

                    attempts++;
                } while (isOverlapping && attempts < 50);

                if (isOverlapping) {
                    position = {
                        x: Math.floor((areaWidth - 40) / 80) * 40,
                        y: Math.floor((areaHeight - 40) / 80) * 40
                    };
                }

                block.style.left = position.x + 'px';
                block.style.top = position.y + 'px';

                buildingArea.appendChild(block);
                this.game.blocks.push(block);
                makeBlockDraggable(block);

                block.style.opacity = '0';
                block.style.transform = 'scale(0.5)';

                requestAnimationFrame(() => {
                    block.style.transition = 'all 0.3s ease-out';
                    block.style.opacity = '1';
                    block.style.transform = 'scale(1)';
                });
            }
        }

        // Make block draggable
        function makeBlockDraggable(block) {
            let isDragging = false;
            let mouseOffsetX = 0;
            let mouseOffsetY = 0;

            block.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            function dragStart(e) {
                if (e.target === block) {
                    e.preventDefault(); // Prevent text selection
                    isDragging = true;
                    block.style.zIndex = '1000';
                    block.style.transition = 'none';

                    // Calculate mouse offset within the block
                    const blockRect = block.getBoundingClientRect();
                    mouseOffsetX = e.clientX - blockRect.left;
                    mouseOffsetY = e.clientY - blockRect.top;

                    console.log('Drag Start:', {
                        mouseX: e.clientX,
                        mouseY: e.clientY,
                        blockLeft: blockRect.left,
                        blockTop: blockRect.top,
                        offsetX: mouseOffsetX,
                        offsetY: mouseOffsetY
                    });
                }
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault(); // Prevent text selection

                    const buildingArea = document.getElementById('buildingArea');
                    const areaRect = buildingArea.getBoundingClientRect();

                    // Calculate position based on mouse position minus the initial offset
                    let newX = e.clientX - mouseOffsetX - areaRect.left;
                    let newY = e.clientY - mouseOffsetY - areaRect.top;

                    // Snap to grid
                    newX = Math.floor(newX / 40) * 40;
                    newY = Math.floor(newY / 40) * 40;

                    // Check bounds
                    newX = Math.max(0, Math.min(newX, buildingArea.clientWidth - 40));
                    newY = Math.max(0, Math.min(newY, buildingArea.clientHeight - 40));

                    console.log('Dragging:', {
                        mouseX: e.clientX,
                        mouseY: e.clientY,
                        newX: newX,
                        newY: newY,
                        offsetX: mouseOffsetX,
                        offsetY: mouseOffsetY
                    });

                    block.style.left = newX + 'px';
                    block.style.top = newY + 'px';
                }
            }

            function dragEnd(e) {
                if (!isDragging) return;

                e.preventDefault(); // Prevent text selection
                isDragging = false;
                block.style.zIndex = '1';
                block.style.transition = 'all 0.3s ease-out';

                const buildingArea = document.getElementById('buildingArea');
                const areaRect = buildingArea.getBoundingClientRect();

                // Calculate final position based on mouse position minus the initial offset
                let finalX = e.clientX - mouseOffsetX - areaRect.left;
                let finalY = e.clientY - mouseOffsetY - areaRect.top;

                // Snap to grid
                finalX = Math.floor(finalX / 40) * 40;
                finalY = Math.floor(finalY / 40) * 40;

                // Check bounds
                finalX = Math.max(0, Math.min(finalX, buildingArea.clientWidth - 40));
                finalY = Math.max(0, Math.min(finalY, buildingArea.clientHeight - 40));

                console.log('Drag End:', {
                    mouseX: e.clientX,
                    mouseY: e.clientY,
                    finalX: finalX,
                    finalY: finalY,
                    offsetX: mouseOffsetX,
                    offsetY: mouseOffsetY
                });

                block.style.left = finalX + 'px';
                block.style.top = finalY + 'px';
            }
        }

        // Profile functions
        function createNewProfile() {
            const nameInput = document.getElementById('newProfileName');
            const name = nameInput.value.trim();

            if (name) {
                if (profileManager.createProfile(name)) {
                    nameInput.value = '';
                    startGame(name);
                } else {
                    alert('A profile with this name already exists!');
                }
            } else {
                alert('Please enter a profile name!');
            }
        }

        function initProfileKeyboardNav() {
            const profileList = document.getElementById('profileList');
            const nameInput = document.getElementById('newProfileName');
            let selectedIndex = -1;

            document.addEventListener('keydown', (e) => {
                const profiles = profileList.getElementsByClassName('profile-item');

                switch (e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        selectedIndex = Math.max(0, selectedIndex - 1);
                        updateSelection();
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        selectedIndex = Math.min(profiles.length - 1, selectedIndex + 1);
                        updateSelection();
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (selectedIndex >= 0 && selectedIndex < profiles.length) {
                            profiles[selectedIndex].click();
                        } else if (document.activeElement === nameInput && nameInput.value.trim()) {
                            createNewProfile();
                        }
                        break;
                    case 'Tab':
                        // Let the browser handle default tab behavior
                        break;
                    default:
                        // If typing in the input, reset selection
                        if (document.activeElement === nameInput) {
                            selectedIndex = -1;
                            updateSelection();
                        }
                }
            });

            function updateSelection() {
                const profiles = profileList.getElementsByClassName('profile-item');
                Array.from(profiles).forEach((profile, index) => {
                    if (index === selectedIndex) {
                        profile.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                        profile.style.transform = 'scale(1.02)';
                    } else {
                        profile.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                        profile.style.transform = 'scale(1)';
                    }
                });
            }

            // Add focus styles to input
            nameInput.addEventListener('focus', () => {
                nameInput.style.outline = '2px solid #ffd700';
            });

            nameInput.addEventListener('blur', () => {
                nameInput.style.outline = 'none';
            });
        }

        function startGame(profileName) {
            if (profileManager) {
                profileManager.startGame(profileName);
            }
        }

        function saveAndExit() {
            if (profileManager) {
                profileManager.exitToProfile();
            }
        }

        // Initialize profile manager and keyboard navigation
        const profileManager = new ProfileManager();
        initProfileKeyboardNav();

        function showAdminStats() {
            const statsDiv = document.getElementById('adminStats');
            if (!statsDiv) return;
            
            const currentProfile = profileManager.currentProfile;
            if (!currentProfile) {
                alert('Please select a profile first!');
                return;
            }

            const profileData = profileManager.profiles[currentProfile];
            let html = `<h2 style="color: #ffd700; text-shadow: 2px 2px #3f3f3f;">Stats for ${currentProfile}</h2>`;
            html += '<table border="1" cellpadding="4" style="border-collapse:collapse; margin-bottom:20px; width:100%; color:#fff;">';
            html += '<tr style="background-color: rgba(255, 193, 7, 0.3);"><th>Word</th><th>Meaning</th><th>Correct</th><th>Incorrect</th><th>Success Rate</th></tr>';
            
            for (const q of vocabulary) {
                const stat = (profileData.questionStats && profileData.questionStats[q.id]) || { correct: 0, incorrect: 0 };
                const total = stat.correct + stat.incorrect;
                const successRate = total > 0 ? ((stat.correct / total) * 100).toFixed(1) + '%' : 'N/A';
                
                html += `<tr>
                    <td>${q.word}</td>
                    <td>${q.meaning}</td>
                    <td>${stat.correct}</td>
                    <td>${stat.incorrect}</td>
                    <td>${successRate}</td>
                </tr>`;
            }
            html += '</table>';
            html += '<button onclick="document.getElementById(\'adminStats\').style.display=\'none\'" style="background-color: rgba(255, 193, 7, 0.7); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-family: \'VT323\', monospace; font-size: 1.1em;">Close</button>';
            statsDiv.innerHTML = html;
            statsDiv.style.display = 'block';

            // Add ESC key handler
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    statsDiv.style.display = 'none';
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }
    </script>
</body>

</html>