<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VocabCraft - Learn Vocabulary with Minecraft</title>
    <!-- Add Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <h1>VocabCraft</h1>

    <div class="game-container" id="gameContainer">
        <div class="game-controls">
            <button class="game-control-button admin" onclick="showAdminStats()">Admin</button>
            <button class="game-control-button exit" onclick="saveAndExit()">Exit</button>
        </div>
        <div class="profile-name-display" id="profileNameDisplay"></div>
        <div class="quiz-section" id="quizSection">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="question" id="question"></div>
            <div class="options" id="options"></div>
        </div>
        <button class="building-toggle" id="buildingToggle">Show Building Area</button>
        <div class="building-section" id="buildingArea">
            <div class="inventory-selector" id="inventorySelector"></div>
        </div>
        <!-- Add Mobile Controls -->
        <div class="mobile-controls">
            <div class="mobile-controls-grid">
                <div class="mobile-control-button" data-action="up">↑</div>
                <div class="mobile-control-button" data-action="left">←</div>
                <div class="mobile-control-button" data-action="right">→</div>
                <div class="mobile-control-button" data-action="down">↓</div>
            </div>
            <div class="mobile-action-buttons">
                <div class="mobile-control-button" data-action="mine">Mine</div>
                <div class="mobile-control-button" data-action="place">Place</div>
                <div class="mobile-control-button" data-action="inventory">Inv</div>
            </div>
        </div>
    </div>

    <div class="profile-container" id="profileContainer">
        <h2>Select or Create a Profile</h2>
        <div class="profile-list" id="profileList"></div>
        <div class="new-profile-form">
            <input type="text" id="newProfileName" placeholder="Enter profile name" maxlength="20">
            <button onclick="createNewProfile()">Create New Profile</button>
        </div>
    </div>

    <div id="adminStats">
        <div class="sticky-header">
            <h2>Admin Statistics</h2>
        </div>
        <div class="content">
            <table class="admin-stats-table">
                <thead>
                    <tr>
                        <th>Profile</th>
                        <th>Questions Answered</th>
                        <th>Correct Answers</th>
                        <th>Success Rate</th>
                    </tr>
                </thead>
                <tbody id="adminStatsBody">
                </tbody>
            </table>
        </div>
        <button class="close-button" onclick="document.getElementById('adminStats').style.display='none'">Close</button>
    </div>

    <script src="version.js" type="module"></script>
    <script>
        // Block textures
        const blockTextures = {
            dirt: {
                backgroundColor: 'rgb(139, 69, 19)',
                backgroundImage: 'linear-gradient(45deg, rgb(139, 69, 19) 25%, rgb(160, 82, 45) 25%, rgb(160, 82, 45) 50%, rgb(139, 69, 19) 50%, rgb(139, 69, 19) 75%, rgb(160, 82, 45) 75%, rgb(160, 82, 45) 100%)',
                backgroundSize: '8px 8px'
            },
            stone: {
                backgroundColor: 'rgb(128, 128, 128)',
                backgroundImage: 'linear-gradient(45deg, rgb(128, 128, 128) 25%, rgb(105, 105, 105) 25%, rgb(105, 105, 105) 50%, rgb(128, 128, 128) 50%, rgb(128, 128, 128) 75%, rgb(105, 105, 105) 75%, rgb(105, 105, 105) 100%)',
                backgroundSize: '8px 8px'
            },
            wood: {
                backgroundColor: 'rgb(160, 82, 45)',
                backgroundImage: 'linear-gradient(90deg, rgb(160, 82, 45) 25%, rgb(139, 69, 19) 25%, rgb(139, 69, 19) 50%, rgb(160, 82, 45) 50%, rgb(160, 82, 45) 75%, rgb(139, 69, 19) 75%, rgb(139, 69, 19) 100%)',
                backgroundSize: '8px 8px'
            },
            glass: {
                backgroundColor: 'rgb(173, 216, 230)',
                backgroundImage: 'linear-gradient(45deg, rgb(173, 216, 230) 25%, rgb(135, 206, 235) 25%, rgb(135, 206, 235) 50%, rgb(173, 216, 230) 50%, rgb(173, 216, 230) 75%, rgb(135, 206, 235) 75%, rgb(135, 206, 235) 100%)',
                backgroundSize: '8px 8px',
                opacity: '0.7'
            }
        };

        // Get block style
        function getBlockStyle(type) {
            return blockTextures[type] || blockTextures.dirt;
        }

        // Profile Management
        class ProfileManager {
            constructor() {
                console.log('Initializing ProfileManager');
                this.profiles = {};
                this.currentProfile = null;
                this.db = null;
                this.auth = null;
                this.isOnline = navigator.onLine;
                this.syncQueue = [];
                this.initFirebase();
                this.setupNetworkListeners();
            }

            logOperation(operation, details) {
                const timestamp = new Date().toISOString();
                const logEntry = {
                    timestamp,
                    operation,
                    details,
                    online: this.isOnline,
                    currentProfile: this.currentProfile,
                    queueLength: this.syncQueue.length
                };
                console.log('Firebase Operation:', logEntry);
                
                // Store logs in localStorage for persistence
                const logs = JSON.parse(localStorage.getItem('firebase_logs') || '[]');
                logs.push(logEntry);
                // Keep only last 100 logs
                if (logs.length > 100) logs.shift();
                localStorage.setItem('firebase_logs', JSON.stringify(logs));
            }

            loadFromLocalStorage() {
                const profiles = localStorage.getItem('vocabcraft_profiles');
                const parsedProfiles = profiles ? JSON.parse(profiles) : {};
                this.logOperation('load_local_storage', {
                    foundProfiles: Object.keys(parsedProfiles).length,
                    profileIds: Object.keys(parsedProfiles),
                    profileNames: Object.values(parsedProfiles).map(p => p.name)
                });
                return parsedProfiles;
            }

            saveToLocalStorage() {
                this.logOperation('save_local_storage', {
                    savingProfiles: Object.keys(this.profiles).length,
                    profileIds: Object.keys(this.profiles),
                    profileNames: Object.values(this.profiles).map(p => p.name)
                });
                localStorage.setItem('vocabcraft_profiles', JSON.stringify(this.profiles));
            }

            async initFirebase() {
                this.logOperation('init', 'Starting Firebase initialization');
                try {
                    const firebaseConfig = {
                        apiKey: "AIzaSyCSZUNwL45dj49Nq-NPD5aAJDi7ooxUxnk",
                        authDomain: "vocabcraft-81563.firebaseapp.com",
                        projectId: "vocabcraft-81563",
                        storageBucket: "vocabcraft-81563.appspot.com",
                        messagingSenderId: "238507816169",
                        appId: "1:238507816169:web:ecdcdce8634db70c53ac78"
                    };

                    if (!firebase.apps.length) {
                        firebase.initializeApp(firebaseConfig);
                        this.logOperation('init', 'Firebase app initialized successfully');
                    }
                    
                    this.db = firebase.firestore();
                    this.auth = firebase.auth();

                    // Set up auth state change listener
                    this.auth.onAuthStateChanged(async (user) => {
                        if (user) {
                            this.logOperation('auth_state', 'User authenticated', { uid: user.uid });
                            try {
                                await this.db.enableNetwork();
                                this.logOperation('network', 'Network enabled after auth');
                            } catch (err) {
                                this.logOperation('network_error', err);
                                console.warn('Failed to enable network:', err);
                                showError('Network error. The app will work in offline mode.', { type: 'warning' });
                            }
                        } else {
                            this.logOperation('auth_state', 'No user authenticated');
                            try {
                                const userCredential = await this.auth.signInAnonymously();
                                this.logOperation('auth', 'Anonymous authentication successful', { uid: userCredential.user.uid });
                            } catch (authError) {
                                this.logOperation('auth_error', authError);
                                console.error('Anonymous authentication failed:', authError);
                                showError('Authentication error. The app will work in offline mode.', { type: 'warning' });
                            }
                        }
                    });

                    // Enable offline persistence
                    try {
                        await this.db.enablePersistence();
                        this.logOperation('persistence', 'Enabled offline persistence');
                    } catch (err) {
                        this.logOperation('persistence_error', err);
                        console.warn('Offline persistence not available:', err);
                        showError('Offline mode is not available. Some features may be limited.', { type: 'warning' });
                    }

                    await this.loadProfiles();
                    this.renderProfileList();
                    this.updateConnectionStatus();
                } catch (error) {
                    this.logOperation('init_error', error);
                    console.error('Firebase initialization error:', error);
                    showError('Failed to initialize the application. Please refresh the page.', { type: 'error' });
                }
            }

            handleConnectionError(error) {
                this.logOperation('connection_error', error);
                if (this.isOnline) {
                    showError('Connection error. Attempting to reconnect...', { type: 'warning' });
                    // Attempt to reconnect
                    this.db.enableNetwork().catch(err => {
                        this.logOperation('reconnect_error', err);
                        showError('Failed to reconnect. Working in offline mode.', { type: 'warning' });
                    });
                }
            }

            showOfflineMessage() {
                showError('Working in offline mode. Changes will sync when connection is restored.', {
                    type: 'warning',
                    position: 'top',
                    duration: 5000
                });
            }

            updateConnectionStatus() {
                if (!this.isOnline) {
                    this.showOfflineMessage();
                }
            }

            setupNetworkListeners() {
                window.addEventListener('online', () => {
                    console.log('Network connection restored');
                    this.isOnline = true;
                    this.logOperation('network_status', 'Online');
                    this.syncWithFirebase();
                    this.updateConnectionStatus();
                });

                window.addEventListener('offline', () => {
                    console.log('Network connection lost');
                    this.isOnline = false;
                    this.logOperation('network_status', 'Offline');
                    this.showOfflineMessage();
                });
            }

            async loadProfiles() {
                this.logOperation('load_start', 'Starting profile load');
                const localProfiles = this.loadFromLocalStorage();
                
                if (this.isOnline) {
                    try {
                        const snapshot = await this.db.collection('profiles').get();
                        const firestoreProfiles = {};
                        snapshot.forEach(doc => {
                            firestoreProfiles[doc.id] = doc.data();
                        });

                        this.logOperation('load_firestore', {
                            profileCount: Object.keys(firestoreProfiles).length,
                            profileIds: Object.keys(firestoreProfiles)
                        });

                        this.profiles = {};
                        
                        // Process Firestore profiles
                        Object.entries(firestoreProfiles).forEach(([id, data]) => {
                            this.profiles[id] = data;
                        });

                        // Process local profiles
                        Object.entries(localProfiles).forEach(([id, localData]) => {
                            if (this.profiles[id]) {
                                const firestoreData = this.profiles[id];
                                if (localData.lastSaved > firestoreData.lastSaved) {
                                    this.logOperation('conflict_resolution', {
                                        profileId: id,
                                        localVersion: localData.version,
                                        firestoreVersion: firestoreData.version,
                                        resolution: 'local_wins'
                                    });
                                    this.syncQueue.push({ type: 'update', id, data: localData });
                                }
                            } else {
                                this.logOperation('new_local_profile', {
                                    profileId: id,
                                    profileName: localData.name
                                });
                                this.syncQueue.push({ type: 'create', id, data: localData });
                            }
                            this.profiles[id] = localData;
                        });

                        await this.syncWithFirebase();
                    } catch (error) {
                        this.logOperation('load_error', error);
                        console.error('Error loading from Firestore:', error);
                        this.profiles = localProfiles;
                        this.showOfflineMessage();
                    }
                } else {
                    this.logOperation('load_offline', {
                        localProfileCount: Object.keys(localProfiles).length
                    });
                    this.profiles = localProfiles;
                    this.showOfflineMessage();
                }
            }

            async syncWithFirebase() {
                if (!this.isOnline) {
                    this.logOperation('sync_skipped', 'Offline - sync skipped');
                    return;
                }

                this.logOperation('sync_start', {
                    queueLength: this.syncQueue.length,
                    operations: this.syncQueue.map(op => op.type)
                });

                try {
                    const batch = this.db.batch();
                    let hasChanges = false;
                    let processedOps = 0;
                    let skippedOps = 0;

                    while (this.syncQueue.length > 0) {
                        const operation = this.syncQueue.shift();
                        const profileRef = this.db.collection('profiles').doc(operation.id);

                        switch (operation.type) {
                            case 'create':
                            case 'update':
                                const doc = await profileRef.get();
                                if (doc.exists) {
                                    const existingData = doc.data();
                                    if (existingData.version > operation.data.version) {
                                        this.logOperation('conflict_detected', {
                                            profileId: operation.id,
                                            operation: operation.type,
                                            localVersion: operation.data.version,
                                            serverVersion: existingData.version,
                                            resolution: 'server_wins'
                                        });
                                        this.profiles[operation.id] = existingData;
                                        this.saveToLocalStorage();
                                        skippedOps++;
                                        continue;
                                    }
                                }
                                batch.set(profileRef, operation.data);
                                hasChanges = true;
                                processedOps++;
                                break;
                            case 'delete':
                                batch.delete(profileRef);
                                hasChanges = true;
                                processedOps++;
                                break;
                        }
                    }

                    if (hasChanges) {
                        await batch.commit();
                        this.logOperation('sync_success', {
                            processedOps,
                            skippedOps,
                            remainingQueue: this.syncQueue.length
                        });
                    } else {
                        this.logOperation('sync_no_changes', {
                            processedOps,
                            skippedOps
                        });
                    }
                } catch (error) {
                    this.logOperation('sync_error', {
                        error: error.message,
                        code: error.code,
                        remainingQueue: this.syncQueue.length
                    });
                    console.error('Error syncing with Firebase:', error);
                    this.syncQueue = [...this.syncQueue, ...this.syncQueue];
                    showError('Failed to sync changes. Will retry later.', { type: 'warning' });
                }
            }

            // Add a method to view logs
            showLogs() {
                const logs = JSON.parse(localStorage.getItem('firebase_logs') || '[]');
                console.table(logs);
                return logs;
            }

            // Generate a UUID v4
            generateUUID() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            async createProfile(name) {
                // Check if name already exists
                const existingProfile = Object.values(this.profiles).find(p => p.name === name);
                if (existingProfile) {
                    return false; // Profile name already exists
                }

                const profileId = this.generateUUID();
                const newProfile = {
                    name: name,
                    score: 0,
                    currentQuestion: 0,
                    blockCounts: {
                        dirt: 0,
                        stone: 0,
                        wood: 0,
                        glass: 0
                    },
                    blocks: [],
                    characterPosition: {
                        x: 280,
                        y: 180
                    },
                    lastSaved: new Date().toISOString(),
                    questionStats: {},
                    version: 1 // Add version for conflict detection
                };

                // Save to localStorage
                this.profiles[profileId] = newProfile;
                this.saveToLocalStorage();

                // Queue for Firebase sync
                if (this.isOnline) {
                    this.syncQueue.push({ type: 'create', id: profileId, data: newProfile });
                    await this.syncWithFirebase();
                }

                this.renderProfileList();
                return profileId; // Return the profileId instead of boolean
            }

            async deleteProfile(profileId) {
                const profile = this.profiles[profileId];
                if (!profile) return;

                if (confirm(`Are you sure you want to delete profile "${profile.name}"?`)) {
                    // Remove from localStorage
                    delete this.profiles[profileId];
                    this.saveToLocalStorage();

                    // Queue for Firebase sync
                    if (this.isOnline) {
                        this.syncQueue.push({ type: 'delete', id: profileId });
                        await this.syncWithFirebase();
                    }

                    this.renderProfileList();
                }
            }

            loadProfile(profileId) {
                return this.profiles[profileId];
            }

            async saveProfile(gameState) {
                if (!this.currentProfile) return;

                const updatedProfile = {
                    ...gameState,
                    lastSaved: new Date().toISOString(),
                    version: (this.profiles[this.currentProfile].version || 0) + 1
                };

                // Save to localStorage
                this.profiles[this.currentProfile] = updatedProfile;
                this.saveToLocalStorage();

                // Queue for Firebase sync
                if (this.isOnline) {
                    this.syncQueue.push({ type: 'update', id: this.currentProfile, data: updatedProfile });
                    await this.syncWithFirebase();
                }
            }

            renderProfileList() {
                const profileList = document.getElementById('profileList');
                if (!profileList) {
                    console.error('Profile list element not found');
                    return;
                }

                profileList.innerHTML = '';

                // Sort profiles by name, handling undefined names
                const sortedProfiles = Object.entries(this.profiles)
                    .filter(([, data]) => data && typeof data === 'object') // Filter out invalid profiles
                    .sort(([, a], [, b]) => {
                        const nameA = a.name || '';
                        const nameB = b.name || '';
                        return nameA.localeCompare(nameB);
                    });

                sortedProfiles.forEach(([id, data]) => {
                    const profileItem = document.createElement('div');
                    profileItem.className = 'profile-item';
                    profileItem.dataset.profileId = id; // Store the ID in a data attribute

                    const profileInfo = document.createElement('div');
                    profileInfo.className = 'profile-info';

                    const profileName = document.createElement('div');
                    profileName.className = 'profile-name';
                    profileName.textContent = data.name || 'Unnamed Profile';

                    const profileStats = document.createElement('div');
                    profileStats.className = 'profile-stats';
                    profileStats.textContent = `Score: ${data.score || 0} | Last saved: ${new Date(data.lastSaved).toLocaleString()}`;

                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'delete-profile';
                    deleteButton.textContent = 'Delete';
                    deleteButton.onclick = (e) => {
                        e.stopPropagation();
                        this.deleteProfile(id);
                    };

                    profileInfo.appendChild(profileName);
                    profileInfo.appendChild(profileStats);
                    profileItem.appendChild(profileInfo);
                    profileItem.appendChild(deleteButton);

                    profileItem.onclick = () => this.startGame(id);
                    profileList.appendChild(profileItem);
                });
            }

            showSaveIndicator() {
                const indicator = document.getElementById('saveIndicator');
                indicator.classList.add('visible');
                setTimeout(() => {
                    indicator.classList.remove('visible');
                }, 2000);
            }

            async startGame(profileId) {
                console.log('Starting game for profile:', profileId);
                const gameState = this.profiles[profileId];
                if (!gameState) {
                    console.error('No game state found for profile:', profileId);
                    return;
                }

                // Set the current profile
                this.currentProfile = profileId;

                // Get all required elements
                const profileContainer = document.getElementById('profileContainer');
                const quizSection = document.getElementById('quizSection');
                const inventorySelector = document.getElementById('inventorySelector');
                const buildingArea = document.getElementById('buildingArea');
                const profileNameDisplay = document.getElementById('profileNameDisplay');
                const buildingToggle = document.getElementById('buildingToggle');

                // Verify all required elements exist
                if (!profileContainer || !quizSection || !inventorySelector || !buildingArea || !profileNameDisplay) {
                    console.error('Required UI elements not found');
                    return;
                }

                // Show loading state
                const loadingMessage = document.createElement('div');
                loadingMessage.style.position = 'fixed';
                loadingMessage.style.top = '50%';
                loadingMessage.style.left = '50%';
                loadingMessage.style.transform = 'translate(-50%, -50%)';
                loadingMessage.style.padding = '20px';
                loadingMessage.style.background = 'rgba(0, 0, 0, 0.8)';
                loadingMessage.style.color = 'white';
                loadingMessage.style.borderRadius = '10px';
                loadingMessage.style.zIndex = '9999';
                loadingMessage.textContent = 'Loading vocabulary...';
                document.body.appendChild(loadingMessage);

                // Hide profile UI
                profileContainer.style.display = 'none';

                // Set initial view state
                quizSection.classList.add('visible');
                buildingArea.classList.remove('visible');
                inventorySelector.classList.add('visible');
                buildingToggle.textContent = 'Show Building Area';

                // Clear any existing game state
                this.cleanupGameState();

                // Initialize new game
                console.log('Creating new game instance');
                window.game = new VocabCraft(this, profileId);

                // Update profile name display with the actual profile name
                profileNameDisplay.textContent = `Profile: ${gameState.name}`;

                // Remove loading message when vocabulary is loaded
                window.game.initializeGame().then(() => {
                    document.body.removeChild(loadingMessage);
                    // Load game state
                    console.log('Loading game state');
                    window.game.loadGame(gameState);
                }).catch(error => {
                    console.error('Error loading vocabulary:', error);
                    loadingMessage.textContent = 'Error loading vocabulary. Please refresh the page.';
                    loadingMessage.style.background = 'rgba(255, 0, 0, 0.8)';
                });
            }

            cleanupGameState() {
                console.log('Cleaning up game state');

                // Get all required elements
                const buildingArea = document.getElementById('buildingArea');
                const quizSection = document.getElementById('quizSection');
                const inventorySelector = document.getElementById('inventorySelector');
                const buildingToggle = document.getElementById('buildingToggle');
                const mobileControls = document.querySelector('.mobile-controls');

                // Reset view states
                if (quizSection) {
                    quizSection.classList.remove('visible');
                }
                if (buildingArea) {
                    // Remove all blocks and characters from building area
                    const existingCharacter = buildingArea.querySelector('.character');
                    if (existingCharacter) {
                        existingCharacter.remove();
                    }
                    
                    // Remove all blocks
                    const blocks = buildingArea.querySelectorAll('.block');
                    blocks.forEach(block => block.remove());
                    
                    // Re-add the inventory selector
                    buildingArea.innerHTML = '<div class="inventory-selector" id="inventorySelector"></div>';
                    buildingArea.classList.remove('visible');
                }
                if (buildingToggle) {
                    buildingToggle.textContent = 'Show Building Area';
                }
                if (mobileControls) {
                    mobileControls.classList.remove('visible');
                    mobileControls.style.display = 'none';
                }

                // Remove character if exists
                if (window.game && window.game.character && window.game.character.element) {
                    window.game.character.element.remove();
                }

                // Hide inventory
                if (inventorySelector) {
                    inventorySelector.classList.remove('visible');
                }

                // Clear game instance
                window.game = null;
            }

            exitToProfile() {
                if (window.game) {
                    const gameState = window.game.saveGame();
                    this.saveProfile(gameState);
                }

                // Show profile UI
                document.getElementById('profileContainer').style.display = 'block';
                document.getElementById('quizSection').style.display = 'none';
                document.getElementById('inventorySelector').classList.remove('visible');

                // Clean up game state
                this.cleanupGameState();

                // Update profile list
                this.renderProfileList();
            }
        }

        // Game class update
        class VocabCraft {
            constructor(profileManager, profileId) {
                console.log('Initializing VocabCraft with profile:', profileId);
                this.profileManager = profileManager;
                this.profileId = profileId;
                this.name = ''; // Initialize name property
                this.vocabulary = [];
                this.currentQuestion = 0;
                this.score = 0;
                this.blocks = [];
                this.blockCounts = {
                    dirt: 0,
                    stone: 0,
                    wood: 0,
                    glass: 0
                };
                this.selectedBlockType = null;

                // Initialize the game in the correct sequence
                this.initializeGame();
            }

            async initializeGame() {
                try {
                    // First load vocabulary
                    await this.loadVocabulary();
                    console.log('Vocabulary loaded:', this.vocabulary.length, 'words');

                    // Then load game state
                    await this.loadGameState();
                    console.log('Game state loaded');

                    // Initialize building area toggle
                    const buildingToggle = document.getElementById('buildingToggle');
                    const buildingArea = document.getElementById('buildingArea');
                    const quizSection = document.getElementById('quizSection');
                    const mobileControls = document.querySelector('.mobile-controls');
                    
                    if (buildingToggle && buildingArea && quizSection) {
                        // Remove any existing event listeners
                        const newBuildingToggle = buildingToggle.cloneNode(true);
                        buildingToggle.parentNode.replaceChild(newBuildingToggle, buildingToggle);

                        newBuildingToggle.addEventListener('click', (e) => {
                            e.preventDefault(); // Prevent any default behavior
                            e.stopPropagation(); // Stop event bubbling
                            
                            const isBuildingVisible = buildingArea.classList.contains('visible');
                            console.log('Toggle clicked, current state:', isBuildingVisible ? 'Building' : 'Quiz');
                            
                            // Toggle views
                            if (isBuildingVisible) {
                                // Switch to quiz view
                                buildingArea.classList.remove('visible');
                                quizSection.classList.add('visible');
                                newBuildingToggle.textContent = 'Show Building Area';
                                
                                // Hide mobile controls
                                if (mobileControls) {
                                    mobileControls.classList.remove('visible');
                                    setTimeout(() => {
                                        mobileControls.style.display = 'none';
                                    }, 300);
                                }
                            } else {
                                // Switch to building view
                                quizSection.classList.remove('visible');
                                buildingArea.classList.add('visible');
                                newBuildingToggle.textContent = 'Show Quiz';
                                
                                // Show mobile controls
                                if (mobileControls) {
                                    mobileControls.style.display = 'block';
                                    setTimeout(() => {
                                        mobileControls.classList.add('visible');
                                    }, 10);
                                }
                            }
                            
                            console.log('View switched:', isBuildingVisible ? 'Quiz' : 'Building');
                        });

                        // Set initial state
                        quizSection.classList.add('visible');
                        buildingArea.classList.remove('visible');
                        newBuildingToggle.textContent = 'Show Building Area';
                    }

                    // Initialize game components
                    this.initGame();
                    this.setupAutoSave();
                } catch (error) {
                    console.error('Error initializing game:', error);
                    showError('Failed to initialize game: ' + error.message);
                }
            }

            async loadGameState() {
                try {
                    const gameState = this.profileManager.loadProfile(this.profileId);
                    if (!gameState) {
                        console.error('No game state found for profile:', this.profileId);
                        showError('No game state found for this profile');
                        return;
                    }

                    console.log('Loading game state:', gameState);
                    this.name = gameState.name || 'Unnamed Profile';
                    this.score = gameState.score || 0;
                    this.currentQuestion = gameState.currentQuestion || 0;
                    this.blockCounts = gameState.blockCounts || {
                        dirt: 0,
                        stone: 0,
                        wood: 0,
                        glass: 0
                    };
                    this.blocks = gameState.blocks || [];

                    // Only update character position if character exists
                    if (gameState.characterPosition && this.character) {
                        this.character.posX = gameState.characterPosition.x;
                        this.character.posY = gameState.characterPosition.y;
                    }

                    // Update display after loading state
                    this.updateDisplay();
                    return true;
                } catch (error) {
                    console.error('Error loading game state:', error);
                    showError('Failed to load game state: ' + error.message);
                    return false;
                }
            }

            updateDisplay() {
                try {
                    const profileNameDisplay = document.getElementById('profileNameDisplay');
                    const quizSection = document.getElementById('quizSection');
                    const inventorySelector = document.getElementById('inventorySelector');

                    if (!profileNameDisplay || !quizSection || !inventorySelector) {
                        throw new Error('Required UI elements not found');
                    }

                    // Update profile name display
                    profileNameDisplay.textContent = `Profile: ${this.name}`;
                    
                    // Update score display
                    const scoreElement = document.getElementById('score');
                    if (scoreElement) {
                        scoreElement.textContent = this.score;
                    }

                    // Update inventory display
                    this.updateBlockCounts();

                    // Show current question
                    this.showQuestion();
                } catch (error) {
                    console.error('Error updating display:', error);
                    showError('Failed to update game display: ' + error.message);
                }
            }

            async loadVocabulary() {
                try {
                    const response = await fetch('/vocabulary.json');
                    if (!response.ok) {
                        throw new Error(`Failed to load vocabulary: ${response.status} ${response.statusText}`);
                    }
                    const data = await response.json();
                    if (!data || !data.vocabulary || !Array.isArray(data.vocabulary)) {
                        throw new Error('Invalid vocabulary data format');
                    }
                    this.vocabulary = data.vocabulary;
                    console.log('Vocabulary loaded successfully:', this.vocabulary.length, 'words');
                } catch (error) {
                    console.error('Error loading vocabulary:', error);
                    showError(`
                        <h3 style="margin-top: 0;">Error Loading Vocabulary</h3>
                        <p>${error.message}</p>
                        <p>Please try refreshing the page. If the problem persists, contact support.</p>
                    `, { duration: 10000 });
                    this.vocabulary = [];
                    throw error;
                }
            }

            initGame() {
                console.log('Initializing game components');
                try {
                    // Get all required elements
                    const profileNameDisplay = document.getElementById('profileNameDisplay');
                    const quizSection = document.getElementById('quizSection');
                    const inventorySelector = document.getElementById('inventorySelector');

                    // Verify elements exist
                    if (!profileNameDisplay || !quizSection || !inventorySelector) {
                        throw new Error('Required UI elements not found');
                    }

                    // Set up UI elements
                    profileNameDisplay.textContent = `Profile: ${this.name}`;
                    quizSection.style.display = 'block';
                    inventorySelector.style.display = 'flex';

                    // Create character
                    console.log('Creating character');
                    this.character = new Character(this);
                    if (this.character && this.character.element) {
                        this.character.element.style.display = 'block';
                    }

                    // Create inventory
                    console.log('Creating inventory');
                    this.createInventorySelector();

                    // Show first question
                    console.log('Showing first question');
                    this.showQuestion();

                    console.log('Game initialization complete');
                } catch (error) {
                    console.error('Error during game initialization:', error);
                }
            }

            setupAutoSave() {
                // Auto-save every 30 seconds
                setInterval(() => {
                    this.saveGame();
                }, 30000);

                // Save when window is closed
                window.addEventListener('beforeunload', () => {
                    this.saveGame();
                });
            }

            loadGame(gameState) {
                console.log('Loading game state:', gameState);
                if (!gameState) {
                    console.error('No game state provided');
                    return;
                }

                this.score = gameState.score || 0;
                this.name = gameState.name;

                // Use questionId if available, otherwise fallback to index
                if (gameState.currentQuestionId) {
                    const idx = this.vocabulary.findIndex(q => q.id === gameState.currentQuestionId);
                    this.currentQuestion = idx !== -1 ? idx : 0;
                } else {
                    this.currentQuestion = gameState.currentQuestion || 0;
                }
                if (this.currentQuestion >= this.vocabulary.length) {
                    this.currentQuestion = 0;
                }

                // Initialize block counts from saved state
                this.blockCounts = gameState.blockCounts || {
                    dirt: 0,
                    stone: 0,
                    wood: 0,
                    glass: 0
                };

                // Clear existing blocks
                const buildingArea = document.getElementById('buildingArea');
                this.blocks.forEach(block => {
                    if (block.parentNode === buildingArea) {
                        block.remove();
                    }
                });
                this.blocks = [];

                // Restore blocks and count them
                if (gameState.blocks && gameState.blocks.length > 0) {
                    console.log('Restoring blocks:', gameState.blocks.length);
                    gameState.blocks.forEach(blockData => {
                        const block = document.createElement('div');
                        block.className = 'block';
                        Object.assign(block.style, getBlockStyle(blockData.type));
                        block.style.left = blockData.x + 'px';
                        block.style.top = blockData.y + 'px';
                        buildingArea.appendChild(block);
                        this.blocks.push(block);
                        makeBlockDraggable(block);
                        console.log('Restored block:', blockData);
                    });
                }

                // Restore character position if available
                if (gameState.characterPosition && this.character) {
                    this.character.posX = gameState.characterPosition.x;
                    this.character.posY = gameState.characterPosition.y;
                    this.character.element.style.left = this.character.posX + 'px';
                    this.character.element.style.top = this.character.posY + 'px';
                }

                // Update inventory display with the loaded block counts
                this.updateBlockCounts();

                // Show current question
                this.showQuestion();

                // Ensure building area is visible
                buildingArea.style.display = 'block';
            }

            saveGame() {
                // Calculate current block counts from placed blocks
                const currentBlockCounts = {
                    dirt: 0,
                    stone: 0,
                    wood: 0,
                    glass: 0
                };

                // Count blocks by type
                this.blocks.forEach(block => {
                    const type = this.character.getBlockType(block);
                    currentBlockCounts[type]++;
                });

                // Add any remaining blocks in inventory
                Object.keys(this.blockCounts).forEach(type => {
                    currentBlockCounts[type] += this.blockCounts[type];
                });

                const gameState = {
                    score: this.score,
                    name: this.name,
                    currentQuestionId: this.vocabulary[this.currentQuestion]?.id || null,
                    currentQuestion: this.currentQuestion,
                    blockCounts: currentBlockCounts, // Save the combined block counts
                    blocks: this.blocks.map(block => ({
                        type: this.character.getBlockType(block),
                        x: parseInt(block.style.left),
                        y: parseInt(block.style.top)
                    })),
                    characterPosition: {
                        x: this.character.posX,
                        y: this.character.posY
                    },
                    questionStats: this.profileManager.profiles[this.profileManager.currentProfile]?.questionStats || {}
                };

                console.log('Saving game state:', gameState);
                this.profileManager.saveProfile(gameState);
                return gameState;
            }

            showQuestion() {
                console.log('Showing question:', this.currentQuestion, 'Vocabulary length:', this.vocabulary.length);
                try {
                    if (!this.vocabulary || this.vocabulary.length === 0) {
                        throw new Error('Vocabulary not loaded yet');
                    }

                    const question = this.vocabulary[this.currentQuestion];
                    if (!question) {
                        throw new Error(`No question found for index: ${this.currentQuestion}`);
                    }

                    const questionElement = document.getElementById('question');
                    const optionsContainer = document.getElementById('options');

                    if (!questionElement || !optionsContainer) {
                        throw new Error('Question elements not found');
                    }

                    questionElement.textContent =
                        `What is the meaning of "${question.word}"?\n\nExample: ${question.example}`;

                    optionsContainer.innerHTML = '';

                    // Create a copy of options array and shuffle it
                    const shuffledOptions = [...question.options];
                    for (let i = shuffledOptions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffledOptions[i], shuffledOptions[j]] = [shuffledOptions[j], shuffledOptions[i]];
                    }

                    // Add shuffled options to the container
                    shuffledOptions.forEach((option) => {
                        const button = document.createElement('button');
                        button.className = 'option';
                        button.textContent = option;
                        button.onclick = () => this.checkAnswer(option);
                        optionsContainer.appendChild(button);
                    });

                    console.log('Question displayed successfully');
                } catch (error) {
                    console.error('Error showing question:', error);
                    showError('Error showing question: ' + error.message);
                }
            }

            checkAnswer(selectedAnswer) {
                const question = this.vocabulary[this.currentQuestion];
                if (!question) {
                    console.error('No question found for index:', this.currentQuestion);
                    return;
                }
                const optionsContainer = document.getElementById('options');
                const buttons = optionsContainer.getElementsByClassName('option');
                // Track stats
                const profile = this.profileManager.profiles[this.profileManager.currentProfile];
                if (profile) {
                    if (!profile.questionStats) profile.questionStats = {};
                    if (!profile.questionStats[question.id]) profile.questionStats[question.id] = { correct: 0, incorrect: 0 };
                }
                let wasCorrect = false;
                Array.from(buttons).forEach(button => {
                    button.disabled = true;
                    if (button.textContent === selectedAnswer) {
                        if (selectedAnswer === question.meaning) {
                            button.style.backgroundColor = '#4CAF50';
                            this.score += 10;
                            document.getElementById('score').textContent = this.score;
                            this.addBonusBlock();
                            wasCorrect = true;
                        } else {
                            button.style.backgroundColor = '#f44336';
                        }
                    }
                });
                Array.from(buttons).forEach(button => {
                    if (button.textContent === question.meaning) {
                        button.style.backgroundColor = '#4CAF50';
                    }
                });
                // Update stats
                if (profile) {
                    if (wasCorrect) {
                        profile.questionStats[question.id].correct++;
                    } else {
                        profile.questionStats[question.id].incorrect++;
                    }
                    this.profileManager.saveProfile(this.saveGame());
                }
                setTimeout(() => {
                    this.currentQuestion = (this.currentQuestion + 1) % this.vocabulary.length;
                    this.showQuestion();
                }, 1500);
            }

            addBonusBlock() {
                const blockTypes = ['dirt', 'stone', 'wood', 'glass'];
                const randomType = blockTypes[Math.floor(Math.random() * blockTypes.length)];

                // Add block to inventory
                this.blockCounts[randomType]++;

                // Find the count element and animate it
                const selector = document.getElementById('inventorySelector');
                const slot = selector.querySelector(`[data-type="${randomType}"]`);
                if (slot) {
                    const countElement = slot.querySelector('.block-count');
                    if (countElement) {
                        countElement.textContent = this.blockCounts[randomType].toString();
                        countElement.classList.remove('pulse');
                        countElement.offsetHeight; // Trigger reflow
                        countElement.classList.add('pulse');
                    }
                }

                // Update all slot appearances
                this.updateBlockCounts();
            }

            createInventorySelector() {
                console.log('Creating inventory selector...');
                const selector = document.getElementById('inventorySelector');
                if (!selector) {
                    console.error('Inventory selector element not found!');
                    return;
                }
                selector.innerHTML = '';
                console.log('Current block counts:', this.blockCounts);

                const blockTypes = [
                    { type: 'dirt', name: 'Dirt' },
                    { type: 'stone', name: 'Stone' },
                    { type: 'wood', name: 'Wood' },
                    { type: 'glass', name: 'Glass' }
                ];

                blockTypes.forEach(blockInfo => {
                    const slot = document.createElement('div');
                    slot.className = 'inventory-slot';
                    slot.dataset.type = blockInfo.type;
                    Object.assign(slot.style, getBlockStyle(blockInfo.type));

                    const count = document.createElement('div');
                    count.className = 'block-count';
                    const currentCount = this.blockCounts[blockInfo.type] || 0;
                    console.log(`Creating slot for ${blockInfo.type} with count:`, currentCount);
                    count.textContent = currentCount.toString();

                    const name = document.createElement('div');
                    name.className = 'block-name';
                    name.textContent = blockInfo.name;

                    slot.appendChild(count);
                    slot.appendChild(name);
                    selector.appendChild(slot);

                    // Update slot appearance based on count
                    this.updateSlotAppearance(slot, blockInfo.type);

                    slot.addEventListener('click', () => {
                        if (this.blockCounts[blockInfo.type] > 0) {
                            this.selectBlock(slot);
                        }
                    });
                });

                // Select first available block by default
                this.selectFirstAvailableBlock();
                console.log('Inventory selector created with slots');
            }

            selectFirstAvailableBlock() {
                const selector = document.getElementById('inventorySelector');
                const slots = selector.querySelectorAll('.inventory-slot');
                
                // Find first available block
                const availableSlot = Array.from(slots).find(slot => 
                    this.blockCounts[slot.dataset.type] > 0
                );

                if (availableSlot) {
                    this.selectBlock(availableSlot);
                } else {
                    // If no blocks available, deselect all
                    this.selectedBlockType = null;
                    slots.forEach(slot => slot.classList.remove('selected'));
                }
            }

            selectBlock(slot) {
                const selector = document.getElementById('inventorySelector');
                selector.querySelectorAll('.inventory-slot').forEach(s => {
                    s.classList.remove('selected');
                });
                slot.classList.add('selected');
                this.selectedBlockType = slot.dataset.type;
            }

            updateSlotAppearance(slot, type) {
                const count = this.blockCounts[type] || 0;
                console.log(`Updating appearance for ${type}, count:`, count);
                const countElement = slot.querySelector('.block-count');
                if (countElement) {
                    console.log(`Found count element for ${type}, updating to:`, count);
                    countElement.textContent = count.toString();
                } else {
                    console.log(`No count element found for ${type}`);
                }

                if (count === 0) {
                    slot.classList.add('empty');
                    // If this was the selected block, select another available one
                    if (this.selectedBlockType === type) {
                        this.selectFirstAvailableBlock();
                    }
                } else {
                    slot.classList.remove('empty');
                }
            }

            updateBlockCounts() {
                console.log('Updating block counts:', this.blockCounts);
                const selector = document.getElementById('inventorySelector');
                if (!selector) {
                    console.error('Inventory selector not found');
                    return;
                }

                selector.querySelectorAll('.inventory-slot').forEach(slot => {
                    const type = slot.dataset.type;
                    const count = this.blockCounts[type] || 0;
                    const countElement = slot.querySelector('.block-count');
                    
                    if (countElement) {
                        countElement.textContent = count.toString();
                        if (count === 0) {
                            slot.classList.add('empty');
                        } else {
                            slot.classList.remove('empty');
                        }
                    }
                });
            }

            placeBlock(x, y) {
                if (this.selectedBlockType && this.blockCounts[this.selectedBlockType] > 0) {
                    const block = document.createElement('div');
                    block.className = 'block';
                    Object.assign(block.style, getBlockStyle(this.selectedBlockType));

                    const gridX = Math.floor(x / 40) * 40;
                    const gridY = Math.floor(y / 40) * 40;

                    block.style.left = gridX + 'px';
                    block.style.top = gridY + 'px';

                    const isOccupied = this.blocks.some(existingBlock => {
                        const existingX = parseInt(existingBlock.style.left);
                        const existingY = parseInt(existingBlock.style.top);
                        return existingX === gridX && existingY === gridY;
                    });

                    if (!isOccupied) {
                        document.getElementById('buildingArea').appendChild(block);
                        this.blocks.push(block);
                        this.blockCounts[this.selectedBlockType]--;
                        this.updateBlockCounts();
                        makeBlockDraggable(block);

                        block.style.opacity = '0';
                        block.style.transform = 'scale(0.5)';
                        requestAnimationFrame(() => {
                            block.style.transition = 'all 0.3s ease-out';
                            block.style.opacity = '1';
                            block.style.transform = 'scale(1)';
                        });

                        // Save state after placing block
                        this.saveGame();
                    }
                }
            }

            addBlock(type) {
                console.log(`Adding block of type ${type}, current count:`, this.blockCounts[type]);
                if (this.blockCounts[type] !== undefined) {
                    this.blockCounts[type]++;
                    console.log(`New count for ${type}:`, this.blockCounts[type]);
                    this.updateBlockCounts();
                    
                    // If this is the first block of this type, select it
                    if (this.blockCounts[type] === 1) {
                        const selector = document.getElementById('inventorySelector');
                        const slot = selector.querySelector(`[data-type="${type}"]`);
                        if (slot) {
                            this.selectBlock(slot);
                        }
                    }
                }
            }
        }

        // Character class to manage the player character
        class Character {
            constructor(game) {
                this.game = game;
                this.element = this.createCharacter();
                this.posX = 280;
                this.posY = 180;
                this.speed = 40;
                this.initControls();

                // Set initial position immediately
                this.element.style.left = this.posX + 'px';
                this.element.style.top = this.posY + 'px';
            }

            createCharacter() {
                // First remove any existing character
                const existingCharacter = document.querySelector('.character');
                if (existingCharacter) {
                    existingCharacter.remove();
                }

                const character = document.createElement('div');
                character.className = 'character';
                character.style.zIndex = '1000'; // Ensure character is always on top

                const head = document.createElement('div');
                head.className = 'character-head';

                const body = document.createElement('div');
                body.className = 'character-body';

                const leftArm = document.createElement('div');
                leftArm.className = 'character-arm left';

                const rightArm = document.createElement('div');
                rightArm.className = 'character-arm right';

                const leftLeg = document.createElement('div');
                leftLeg.className = 'character-leg left';

                const rightLeg = document.createElement('div');
                rightLeg.className = 'character-leg right';

                const bag = document.createElement('div');
                bag.className = 'character-bag';

                character.appendChild(head);
                character.appendChild(body);
                character.appendChild(leftArm);
                character.appendChild(rightArm);
                character.appendChild(leftLeg);
                character.appendChild(rightLeg);
                character.appendChild(bag);

                character.style.left = this.posX + 'px';
                character.style.top = this.posY + 'px';
                
                const buildingArea = document.getElementById('buildingArea');
                if (buildingArea) {
                    buildingArea.appendChild(character);
                }

                return character;
            }

            initControls() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        this.mineBlock();
                        return;
                    }

                    // Inventory controls
                    if (e.key.toLowerCase() === 'a') {
                        this.selectPreviousBlock();
                        return;
                    }
                    if (e.key.toLowerCase() === 's') {
                        this.selectNextBlock();
                        return;
                    }
                    if (e.key.toLowerCase() === 'd') {
                        this.placeBlockInFront();
                        return;
                    }

                    let newX = this.posX;
                    let newY = this.posY;
                    let direction = '';

                    switch (e.key) {
                        case 'ArrowLeft':
                            newX = Math.max(0, this.posX - this.speed);
                            direction = 'left';
                            break;
                        case 'ArrowRight':
                            newX = Math.min(document.getElementById('buildingArea').clientWidth - 40, this.posX + this.speed);
                            direction = 'right';
                            break;
                        case 'ArrowUp':
                            newY = Math.max(0, this.posY - this.speed);
                            direction = 'back';
                            break;
                        case 'ArrowDown':
                            newY = Math.min(document.getElementById('buildingArea').clientHeight - 40, this.posY + this.speed);
                            direction = 'front';
                            break;
                    }

                    if (!this.willCollide(newX, newY)) {
                        this.posX = newX;
                        this.posY = newY;
                        this.element.style.left = this.posX + 'px';
                        this.element.style.top = this.posY + 'px';

                        // Update facing direction
                        this.element.className = 'character';
                        if (direction) {
                            this.element.classList.add('facing-' + direction);
                        }
                    }
                });

                // Touch controls
                const mobileControls = document.querySelector('.mobile-controls');
                if (mobileControls) {
                    mobileControls.addEventListener('touchstart', (e) => {
                        const button = e.target.closest('.mobile-control-button');
                        if (!button) return;

                        e.preventDefault();
                        const action = button.dataset.action;

                        switch (action) {
                            case 'up':
                                this.moveCharacter(0, -this.speed, 'back');
                                break;
                            case 'down':
                                this.moveCharacter(0, this.speed, 'front');
                                break;
                            case 'left':
                                this.moveCharacter(-this.speed, 0, 'left');
                                break;
                            case 'right':
                                this.moveCharacter(this.speed, 0, 'right');
                                break;
                            case 'mine':
                                this.mineBlock();
                                break;
                            case 'place':
                                this.placeBlockInFront();
                                break;
                            case 'inventory':
                                this.selectNextBlock();
                                break;
                        }
                    });
                }
            }

            moveCharacter(deltaX, deltaY, direction) {
                const newX = Math.max(0, Math.min(document.getElementById('buildingArea').clientWidth - 40, this.posX + deltaX));
                const newY = Math.max(0, Math.min(document.getElementById('buildingArea').clientHeight - 40, this.posY + deltaY));

                if (!this.willCollide(newX, newY)) {
                    this.posX = newX;
                    this.posY = newY;
                    this.element.style.left = this.posX + 'px';
                    this.element.style.top = this.posY + 'px';

                    // Update facing direction
                    this.element.className = 'character';
                    if (direction) {
                        this.element.classList.add('facing-' + direction);
                    }
                }
            }

            selectPreviousBlock() {
                const selector = document.getElementById('inventorySelector');
                const slots = selector.querySelectorAll('.inventory-slot');
                const currentIndex = Array.from(slots).findIndex(slot => slot.classList.contains('selected'));

                let newIndex = currentIndex - 1;
                if (newIndex < 0) newIndex = slots.length - 1;

                // Find the first non-empty slot going backwards
                while (newIndex !== currentIndex) {
                    const slot = slots[newIndex];
                    const type = slot.dataset.type;
                    if (this.game.blockCounts[type] > 0) {
                        this.selectBlock(slot);
                        break;
                    }
                    newIndex = (newIndex - 1 + slots.length) % slots.length;
                }
            }

            selectNextBlock() {
                const selector = document.getElementById('inventorySelector');
                const slots = selector.querySelectorAll('.inventory-slot');
                const currentIndex = Array.from(slots).findIndex(slot => slot.classList.contains('selected'));

                let newIndex = (currentIndex + 1) % slots.length;

                // Find the first non-empty slot going forwards
                while (newIndex !== currentIndex) {
                    const slot = slots[newIndex];
                    const type = slot.dataset.type;
                    if (this.game.blockCounts[type] > 0) {
                        this.selectBlock(slot);
                        break;
                    }
                    newIndex = (newIndex + 1) % slots.length;
                }
            }

            selectBlock(slot) {
                const selector = document.getElementById('inventorySelector');
                selector.querySelectorAll('.inventory-slot').forEach(s => {
                    s.classList.remove('selected');
                });
                slot.classList.add('selected');
                this.game.selectedBlockType = slot.dataset.type;
            }

            placeBlockInFront() {
                if (!this.game.selectedBlockType || this.game.blockCounts[this.game.selectedBlockType] <= 0) {
                    return;
                }

                // Calculate position in front of character based on facing direction
                let placeX = this.posX;
                let placeY = this.posY;

                // Determine placement position based on character's facing direction
                if (this.element.classList.contains('facing-left')) {
                    placeX -= 40;
                } else if (this.element.classList.contains('facing-right')) {
                    placeX += 40;
                } else if (this.element.classList.contains('facing-back')) {
                    placeY -= 40;
                } else { // facing front (default)
                    placeY += 40;
                }

                // Snap to grid
                placeX = Math.floor(placeX / 40) * 40;
                placeY = Math.floor(placeY / 40) * 40;

                // Check if position is within bounds
                const buildingArea = document.getElementById('buildingArea');
                if (placeX < 0 || placeX > buildingArea.clientWidth - 40 ||
                    placeY < 0 || placeY > buildingArea.clientHeight - 40) {
                    return;
                }

                // Check if position is already occupied
                const isOccupied = this.game.blocks.some(block => {
                    const blockX = parseInt(block.style.left);
                    const blockY = parseInt(block.style.top);
                    return blockX === placeX && blockY === placeY;
                });

                if (!isOccupied) {
                    const block = document.createElement('div');
                    block.className = 'block';
                    Object.assign(block.style, getBlockStyle(this.game.selectedBlockType));
                    block.style.left = placeX + 'px';
                    block.style.top = placeY + 'px';

                    buildingArea.appendChild(block);
                    this.game.blocks.push(block);
                    this.game.blockCounts[this.game.selectedBlockType]--;
                    this.game.updateBlockCounts();
                    makeBlockDraggable(block);

                    // Add placement animation
                    block.style.opacity = '0';
                    block.style.transform = 'scale(0.5)';
                    requestAnimationFrame(() => {
                        block.style.transition = 'all 0.3s ease-out';
                        block.style.opacity = '1';
                        block.style.transform = 'scale(1)';
                    });
                }
            }

            willCollide(newX, newY) {
                return this.game.blocks.some(block => {
                    const blockX = parseInt(block.style.left);
                    const blockY = parseInt(block.style.top);
                    return Math.abs(blockX - newX) < 40 && Math.abs(blockY - newY) < 40;
                });
            }

            isOnBlock() {
                const characterCenterX = this.posX + 20;
                const characterCenterY = this.posY + 20;

                return this.game.blocks.some(block => {
                    const blockX = parseInt(block.style.left);
                    const blockY = parseInt(block.style.top);
                    const blockCenterX = blockX + 20;
                    const blockCenterY = blockY + 20;

                    const distanceX = Math.abs(characterCenterX - blockCenterX);
                    const distanceY = Math.abs(characterCenterY - blockCenterY);

                    return distanceX <= 60 && distanceY <= 60;
                });
            }

            getBlockType(block) {
                // Get the computed style of the block
                const style = window.getComputedStyle(block);
                const backgroundColor = style.backgroundColor;

                // Convert RGB colors to comparable format
                const normalizeColor = (color) => {
                    // Convert rgb(r, g, b) to rgb(r,g,b)
                    return color.replace(/\s/g, '').toLowerCase();
                };

                const normalizedBgColor = normalizeColor(backgroundColor);

                // Define color mappings for each block type
                const colorMappings = {
                    'rgb(139,69,19)': 'dirt',      // #8B4513
                    'rgb(128,128,128)': 'stone',   // #808080
                    'rgb(160,82,45)': 'wood',      // #A0522D
                    'rgb(173,216,230)': 'glass'    // #ADD8E6
                };

                // Check if the color matches any of our known block types
                for (const [color, type] of Object.entries(colorMappings)) {
                    if (normalizeColor(color) === normalizedBgColor) {
                        return type;
                    }
                }

                // If no match found, try to determine by background image
                const backgroundImage = style.backgroundImage;
                if (backgroundImage.includes('linear-gradient')) {
                    if (backgroundImage.includes('45deg')) {
                        if (backgroundImage.includes('173,216,230')) return 'glass';
                        if (backgroundImage.includes('139,69,19')) return 'dirt';
                        if (backgroundImage.includes('128,128,128')) return 'stone';
                    } else if (backgroundImage.includes('90deg')) {
                        return 'wood';
                    }
                }

                return 'dirt'; // Default to dirt if type can't be determined
            }

            mineBlock() {
                if (!this.isOnBlock()) return;

                const characterCenterX = this.posX + 20;
                const characterCenterY = this.posY + 20;

                let closestBlock = null;
                let minDistance = Infinity;

                this.game.blocks.forEach(block => {
                    if (block.closest('.block-palette')) return;

                    const blockX = parseInt(block.style.left);
                    const blockY = parseInt(block.style.top);
                    const blockCenterX = blockX + 20;
                    const blockCenterY = blockY + 20;

                    const distanceX = Math.abs(characterCenterX - blockCenterX);
                    const distanceY = Math.abs(characterCenterY - blockCenterY);
                    const totalDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

                    if (totalDistance < minDistance && distanceX <= 60 && distanceY <= 60) {
                        minDistance = totalDistance;
                        closestBlock = block;
                    }
                });

                if (closestBlock) {
                    const blockType = this.getBlockType(closestBlock);
                    closestBlock.classList.add('mining');
                    closestBlock.style.animation = 'mining 0.5s ease-in-out';

                    setTimeout(() => {
                        if (closestBlock.parentNode) {
                            closestBlock.remove();
                            this.game.blocks = this.game.blocks.filter(b => b !== closestBlock);
                            this.game.addBlock(blockType);
                            
                            // Save state after mining block
                            this.game.saveGame();
                        }
                    }, 500);
                }
            }

            addBlock() {
                const block = document.createElement('div');
                block.className = 'block';

                const blockTypes = ['dirt', 'stone', 'wood', 'glass'];
                const randomType = blockTypes[Math.floor(Math.random() * blockTypes.length)];
                Object.assign(block.style, getBlockStyle(randomType));

                const buildingArea = document.getElementById('buildingArea');
                const areaWidth = buildingArea.clientWidth - 40;
                const areaHeight = buildingArea.clientHeight - 40;

                let attempts = 0;
                let position;
                let isOverlapping;

                do {
                    const x = Math.floor(Math.random() * (areaWidth / 40)) * 40;
                    const y = Math.floor(Math.random() * (areaHeight / 40)) * 40;
                    position = { x, y };

                    isOverlapping = this.game.blocks.some(existingBlock => {
                        const existingX = parseInt(existingBlock.style.left);
                        const existingY = parseInt(existingBlock.style.top);
                        return existingX === x && existingY === y;
                    });

                    attempts++;
                } while (isOverlapping && attempts < 50);

                if (isOverlapping) {
                    position = {
                        x: Math.floor((areaWidth - 40) / 80) * 40,
                        y: Math.floor((areaHeight - 40) / 80) * 40
                    };
                }

                block.style.left = position.x + 'px';
                block.style.top = position.y + 'px';

                buildingArea.appendChild(block);
                this.game.blocks.push(block);
                makeBlockDraggable(block);

                block.style.opacity = '0';
                block.style.transform = 'scale(0.5)';

                requestAnimationFrame(() => {
                    block.style.transition = 'all 0.3s ease-out';
                    block.style.opacity = '1';
                    block.style.transform = 'scale(1)';
                });
            }
        }

        // Make block draggable
        function makeBlockDraggable(block) {
            let isDragging = false;
            let mouseOffsetX = 0;
            let mouseOffsetY = 0;

            block.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            function dragStart(e) {
                if (e.target === block) {
                    e.preventDefault(); // Prevent text selection
                    isDragging = true;
                    block.style.zIndex = '1000';
                    block.style.transition = 'none';

                    // Calculate mouse offset within the block
                    const blockRect = block.getBoundingClientRect();
                    mouseOffsetX = e.clientX - blockRect.left;
                    mouseOffsetY = e.clientY - blockRect.top;

                    console.log('Drag Start:', {
                        mouseX: e.clientX,
                        mouseY: e.clientY,
                        blockLeft: blockRect.left,
                        blockTop: blockRect.top,
                        offsetX: mouseOffsetX,
                        offsetY: mouseOffsetY
                    });
                }
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault(); // Prevent text selection

                    const buildingArea = document.getElementById('buildingArea');
                    const areaRect = buildingArea.getBoundingClientRect();

                    // Calculate position based on mouse position minus the initial offset
                    let newX = e.clientX - mouseOffsetX - areaRect.left;
                    let newY = e.clientY - mouseOffsetY - areaRect.top;

                    // Snap to grid
                    newX = Math.floor(newX / 40) * 40;
                    newY = Math.floor(newY / 40) * 40;

                    // Check bounds
                    newX = Math.max(0, Math.min(newX, buildingArea.clientWidth - 40));
                    newY = Math.max(0, Math.min(newY, buildingArea.clientHeight - 40));

                    console.log('Dragging:', {
                        mouseX: e.clientX,
                        mouseY: e.clientY,
                        newX: newX,
                        newY: newY,
                        offsetX: mouseOffsetX,
                        offsetY: mouseOffsetY
                    });

                    block.style.left = newX + 'px';
                    block.style.top = newY + 'px';
                }
            }

            function dragEnd(e) {
                if (!isDragging) return;

                e.preventDefault(); // Prevent text selection
                isDragging = false;
                block.style.zIndex = '1';
                block.style.transition = 'all 0.3s ease-out';

                const buildingArea = document.getElementById('buildingArea');
                const areaRect = buildingArea.getBoundingClientRect();

                // Calculate final position based on mouse position minus the initial offset
                let finalX = e.clientX - mouseOffsetX - areaRect.left;
                let finalY = e.clientY - mouseOffsetY - areaRect.top;

                // Snap to grid
                finalX = Math.floor(finalX / 40) * 40;
                finalY = Math.floor(finalY / 40) * 40;

                // Check bounds
                finalX = Math.max(0, Math.min(finalX, buildingArea.clientWidth - 40));
                finalY = Math.max(0, Math.min(finalY, buildingArea.clientHeight - 40));

                console.log('Drag End:', {
                    mouseX: e.clientX,
                    mouseY: e.clientY,
                    finalX: finalX,
                    finalY: finalY,
                    offsetX: mouseOffsetX,
                    offsetY: mouseOffsetY
                });

                block.style.left = finalX + 'px';
                block.style.top = finalY + 'px';
            }
        }

        // Profile functions
        async function createNewProfile() {
            const nameInput = document.getElementById('newProfileName');
            const name = nameInput.value.trim();

            if (name) {
                const profileId = await profileManager.createProfile(name);
                if (profileId) {
                    nameInput.value = '';
                    startGame(profileId);
                } else {
                    alert('A profile with this name already exists!');
                }
            } else {
                alert('Please enter a profile name!');
            }
        }

        async function startGame(profileId) {
            if (profileManager) {
                await profileManager.startGame(profileId);
            }
        }

        async function saveAndExit() {
            if (profileManager) {
                await profileManager.exitToProfile();
            }
        }

        // Initialize profile manager and keyboard navigation
        const profileManager = new ProfileManager();
        
        function initProfileKeyboardNav() {
            document.addEventListener('keydown', (e) => {
                // Only handle keyboard navigation when profile container is visible
                const profileContainer = document.getElementById('profileContainer');
                if (!profileContainer || profileContainer.style.display === 'none') {
                    return;
                }

                const profileList = document.getElementById('profileList');
                const profiles = profileList.querySelectorAll('.profile-item');
                const currentIndex = Array.from(profiles).findIndex(p => p.classList.contains('selected'));

                switch (e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        if (currentIndex > 0) {
                            profiles[currentIndex].classList.remove('selected');
                            profiles[currentIndex - 1].classList.add('selected');
                            profiles[currentIndex - 1].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        if (currentIndex < profiles.length - 1) {
                            profiles[currentIndex].classList.remove('selected');
                            profiles[currentIndex + 1].classList.add('selected');
                            profiles[currentIndex + 1].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (currentIndex !== -1) {
                            const profileId = profiles[currentIndex].dataset.profileId;
                            startGame(profileId);
                        }
                        break;
                }
            });

            // Add initial selection to first profile if exists
            const profileList = document.getElementById('profileList');
            const firstProfile = profileList.querySelector('.profile-item');
            if (firstProfile) {
                firstProfile.classList.add('selected');
            }
        }

        initProfileKeyboardNav();

        async function showAdminStats() {
            const statsDiv = document.getElementById('adminStats');
            if (!statsDiv) return;
            
            const currentProfile = profileManager.currentProfile;
            if (!currentProfile) {
                showError('Please select a profile first!', 3000, 'center', 'warning');
                return;
            }

            // Refresh profile data from Firestore
            await profileManager.loadProfiles();
            const profileData = profileManager.profiles[currentProfile];
            const contentDiv = statsDiv.querySelector('.content');
            
            // Update the title with profile name
            const titleElement = statsDiv.querySelector('.sticky-header h2');
            titleElement.textContent = `Stats for ${profileData.name}`;
            
            let html = '';
            
            // Group questions by prefix
            const groupedQuestions = {};
            window.game.vocabulary.forEach(q => {
                const prefix = q.id.split('-')[0];
                if (!groupedQuestions[prefix]) {
                    groupedQuestions[prefix] = [];
                }
                groupedQuestions[prefix].push(q);
            });

            // Sort prefixes with proper lesson number handling
            const sortedPrefixes = Object.keys(groupedQuestions).sort((a, b) => {
                // If both are ww4l prefixes, sort by lesson number
                if (a.startsWith('ww4l') && b.startsWith('ww4l')) {
                    const numA = parseInt(a.substring(4));
                    const numB = parseInt(b.substring(4));
                    return numA - numB;
                }
                // Otherwise, sort alphabetically
                return a.localeCompare(b);
            });

            // Create table for each group
            sortedPrefixes.forEach(prefix => {
                // Format the prefix for display
                let displayPrefix = prefix;
                if (prefix.startsWith('ww4l')) {
                    const lessonNum = prefix.substring(4);
                    displayPrefix = `ww4 lesson${lessonNum.padStart(2, '0')}`;
                }
                
                html += `<h3 style="color: #ffd700; margin-top: 20px;">${displayPrefix}</h3>`;
                html += '<table class="admin-stats-table">';
                html += '<tr><th>Word</th><th>Meaning</th><th>Correct</th><th>Incorrect</th><th>Success Rate</th></tr>';
                
                // Sort questions within group by their number
                const sortedQuestions = groupedQuestions[prefix].sort((a, b) => {
                    const numA = parseInt(a.id.split('-')[1]);
                    const numB = parseInt(b.id.split('-')[1]);
                    return numA - numB;
                });

                sortedQuestions.forEach(q => {
                    const stat = (profileData.questionStats && profileData.questionStats[q.id]) || { correct: 0, incorrect: 0 };
                    const total = stat.correct + stat.incorrect;
                    const successRate = total > 0 ? ((stat.correct / total) * 100).toFixed(1) + '%' : 'N/A';
                    
                    // Color coding for success rate
                    let successRateColor = '#fff'; // default white
                    if (total > 0) {
                        const rate = (stat.correct / total) * 100;
                        if (rate >= 70) {
                            successRateColor = '#4CAF50'; // green for good performance
                        } else if (rate < 50) {
                            successRateColor = '#f44336'; // red for poor performance
                        }
                    }
                    
                    html += `<tr>
                        <td>${q.word}</td>
                        <td>${q.meaning}</td>
                        <td>${stat.correct}</td>
                        <td>${stat.incorrect}</td>
                        <td style="color: ${successRateColor}">${successRate}</td>
                    </tr>`;
                });
                html += '</table>';
            });

            contentDiv.innerHTML = html;
            statsDiv.style.display = 'flex';

            // Add ESC key handler
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    statsDiv.style.display = 'none';
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }

        // Ensure admin stats is hidden on page load
        document.addEventListener('DOMContentLoaded', () => {
            const adminStats = document.getElementById('adminStats');
            if (adminStats) {
                adminStats.style.display = 'none';
            }
        });

        // Add this utility function at the top of the script section, after the style tag
        function showError(message, duration = 3000, position = 'center', type = 'error', autoClose = true) {
            const errorDiv = document.createElement('div');
            errorDiv.className = `error-message ${position} ${type}`;
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);

            // Force a reflow to ensure the transition works
            errorDiv.offsetHeight;
            errorDiv.style.opacity = '1';

            if (autoClose) {
                setTimeout(() => {
                    errorDiv.style.opacity = '0';
                    setTimeout(() => errorDiv.remove(), 300);
                }, duration);
            }

            return errorDiv;
        }
    </script>
</body>

</html>