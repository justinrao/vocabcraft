<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VocabCraft - Learn Vocabulary with Minecraft</title>
    <!-- Add Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            font-family: 'VT323', monospace;
            background-color: #87CEEB;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-image: url('https://raw.githubusercontent.com/misode/mcmeta/master/assets/minecraft/textures/block/grass_block_side.png');
            background-size: 64px 64px;
            image-rendering: pixelated;
            min-height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            color: #fff;
            text-shadow: 2px 2px #3f3f3f;
            font-size: 3em;
            margin-bottom: 20px;
            text-transform: uppercase;
            text-align: center;
        }

        .game-container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .quiz-section {
            background-color: #8B4513;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            width: 400px;
            border: 4px solid #5c2e0a;
            image-rendering: pixelated;
            transition: opacity 0.3s ease;
        }

        .quiz-section.visible {
            display: block !important;
            opacity: 1;
        }

        .building-section {
            background-color: #5c2e0a;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            width: 600px;
            height: 400px;
            position: relative;
            border: 4px solid #3d1f07;
            image-rendering: pixelated;
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.2) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.2) 1px, transparent 1px);
            background-size: 40px 40px;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: opacity 0.3s ease;
        }

        .building-section.visible {
            display: block !important;
            opacity: 1;
        }

        .building-toggle {
            display: none;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #5c2e0a;
            padding: 10px 20px;
            border-radius: 10px;
            margin: 10px auto;
            font-family: 'VT323', monospace;
            font-size: 1.2em;
            cursor: pointer;
            width: 200px;
            text-align: center;
            z-index: 1000;
        }

        .building-toggle:active {
            background-color: rgba(92, 46, 10, 0.7);
        }

        .question {
            color: white;
            font-size: 1.4em;
            margin-bottom: 20px;
            text-shadow: 2px 2px #3f3f3f;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option {
            background-color: #A0522D;
            color: white;
            padding: 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1.2em;
            text-shadow: 1px 1px #3f3f3f;
            border: 2px solid #5c2e0a;
        }

        .option:hover {
            background-color: #8B4513;
            transform: scale(1.02);
        }

        .block {
            width: 40px;
            height: 40px;
            position: absolute;
            cursor: move;
            image-rendering: pixelated;
            border: 1px solid rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .block.mining {
            animation: mining 0.5s ease-in-out;
        }

        @keyframes mining {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(0.8);
            }

            100% {
                transform: scale(1);
            }
        }

        .score {
            color: white;
            font-size: 1.4em;
            margin-bottom: 20px;
            text-shadow: 2px 2px #3f3f3f;
        }

        .block-palette,
        .block-palette-container,
        .block-palette-item,
        .block-count {
            display: none !important;
        }

        .building-section.drag-over {
            background-color: #4a2510;
        }

        .character {
            display: none;
            /* Hide by default */
            width: 40px;
            height: 40px;
            position: absolute;
            transition: all 0.1s ease;
            z-index: 1000;
        }

        .character-head {
            width: 20px;
            height: 20px;
            background-color: #FFD700;
            position: absolute;
            top: 0;
            left: 10px;
            border: 2px solid #000;
        }

        .character-body {
            width: 20px;
            height: 20px;
            background-color: #3B5998;
            position: absolute;
            top: 20px;
            left: 10px;
            border: 2px solid #000;
        }

        .character-arm {
            width: 8px;
            height: 20px;
            background-color: #3B5998;
            position: absolute;
            top: 20px;
            border: 2px solid #000;
        }

        .character-arm.left {
            left: 2px;
        }

        .character-arm.right {
            right: 2px;
        }

        .character-leg {
            width: 8px;
            height: 20px;
            background-color: #2B3F6B;
            position: absolute;
            bottom: 0;
            border: 2px solid #000;
        }

        .character-leg.left {
            left: 10px;
        }

        .character-leg.right {
            right: 10px;
        }

        .character.facing-left .character-arm.left {
            transform: rotate(-30deg);
            transform-origin: top center;
        }

        .character.facing-left .character-arm.right {
            transform: rotate(30deg);
            transform-origin: top center;
        }

        .character.facing-right .character-arm.left {
            transform: rotate(30deg);
            transform-origin: top center;
        }

        .character.facing-right .character-arm.right {
            transform: rotate(-30deg);
            transform-origin: top center;
        }

        .character.facing-back .character-arm.left {
            transform: rotate(-15deg);
            transform-origin: top center;
        }

        .character.facing-back .character-arm.right {
            transform: rotate(15deg);
            transform-origin: top center;
        }

        .character-bag {
            width: 16px;
            height: 16px;
            background-color: #8B4513;
            position: absolute;
            bottom: 0;
            left: 12px;
            border: 2px solid #000;
            z-index: 999;
        }

        .character-bag::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: #A0522D;
            top: 4px;
            left: 4px;
            border: 1px solid #000;
        }

        .inventory {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 1.2em;
            text-shadow: 1px 1px #000;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .inventory-selector {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            display: none; /* Hide by default */
            gap: 10px;
            z-index: 1000;
            border: 2px solid #5c2e0a;
            min-height: 80px;
        }

        .inventory-selector.visible {
            display: flex;
        }

        .inventory-slot {
            width: 50px;
            height: 50px;
            border: 2px solid #fff;
            border-radius: 5px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            background-size: cover;
            image-rendering: pixelated;
            margin: 15px 5px;
            touch-action: manipulation;
        }

        .inventory-slot:hover {
            transform: scale(1.1);
        }

        .inventory-slot.selected {
            border-color: #ffd700;
            box-shadow: 0 0 10px #ffd700;
        }

        .inventory-slot .block-count {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #ffd700;
            color: black;
            padding: 2px 5px;
            border-radius: 50%;
            font-size: 1em;
            font-weight: bold;
            min-width: 22px;
            height: 22px;
            text-align: center;
            border: 2px solid #000;
            z-index: 1001;
            display: block !important;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.4);
            transition: all 0.2s ease-out;
        }

        .inventory-slot .block-count.pulse {
            animation: countPulse 0.5s ease-out;
        }

        .inventory-slot .block-name {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 1em;
            white-space: nowrap;
            z-index: 1001;
        }

        .inventory-slot.empty {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .inventory-slot.empty .block-count {
            background-color: #ff4444;
        }

        .profile-name-display {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 1.2em;
            z-index: 1000;
        }

        .profile-container {
            display: block;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            color: white;
            text-align: center;
            max-width: 600px;
            margin: 20px auto;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001;
        }

        .profile-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .profile-item {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .profile-item:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.02);
        }

        .profile-item .profile-info {
            text-align: left;
        }

        .profile-item .profile-name {
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .profile-item .profile-stats {
            font-size: 0.9em;
            color: #ccc;
        }

        .profile-item .delete-profile {
            background-color: #ff4444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .profile-item .delete-profile:hover {
            opacity: 1;
        }

        .new-profile-form {
            margin-top: 20px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .new-profile-form input {
            padding: 10px;
            margin: 10px 0;
            width: 200px;
            border: none;
            border-radius: 5px;
            font-family: 'VT323', monospace;
            font-size: 1.1em;
        }

        .new-profile-form button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1.1em;
            margin-top: 10px;
        }

        .new-profile-form button:hover {
            background-color: #45a049;
        }

        .save-indicator {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .save-indicator.visible {
            opacity: 1;
        }

        .game-controls {
            position: fixed;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .game-control-button {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1.1em;
            transition: all 0.2s ease;
        }

        .game-control-button:hover {
            background-color: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }

        .game-control-button.save {
            background-color: rgba(76, 175, 80, 0.7);
        }

        .game-control-button.save:hover {
            background-color: rgba(76, 175, 80, 0.9);
        }

        .game-control-button.exit {
            background-color: rgba(244, 67, 54, 0.7);
        }

        .game-control-button.exit:hover {
            background-color: rgba(244, 67, 54, 0.9);
        }

        .game-control-button.admin {
            background-color: rgba(255, 193, 7, 0.7);
        }

        .game-control-button.admin:hover {
            background-color: rgba(255, 193, 7, 0.9);
        }

        @keyframes blockAdded {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .block-added-animation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 1000;
            animation: blockAdded 0.5s ease-out forwards;
        }

        @keyframes countPulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(2);
                color: #000;
                background-color: #ffd700;
                box-shadow: 0 0 15px #ffd700;
            }

            100% {
                transform: scale(1);
            }
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 300px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mobile-controls.visible {
            opacity: 1;
        }

        .mobile-controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 10px;
        }

        .mobile-control-button {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #5c2e0a;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
        }

        .mobile-control-button:active {
            background-color: rgba(92, 46, 10, 0.7);
        }

        .mobile-action-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        /* Media Queries */
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                width: 100%;
                padding: 10px;
            }

            .quiz-section {
                width: 100%;
                max-width: 400px;
                margin: 0 auto;
            }

            .building-section {
                width: 100%;
                height: 300px;
            }

            .building-toggle {
                display: block;
            }

            .mobile-controls {
                display: none;
            }

            /* Hide both sections by default on mobile */
            .quiz-section,
            .building-section {
                display: none !important;
            }

            /* Show sections when they have the visible class */
            .quiz-section.visible,
            .building-section.visible {
                display: block !important;
            }

            /* Show mobile controls only when building area is visible */
            .building-section.visible ~ .mobile-controls {
                display: block;
            }
        }

        @media (max-width: 480px) {
            .building-section {
                height: 250px;
            }

            .inventory-slot {
                width: 35px;
                height: 35px;
                margin: 8px 2px;
            }

            .mobile-control-button {
                padding: 12px;
            }
        }
    </style>
</head>

<body>
    <h1>VocabCraft</h1>

    <div class="game-container" id="gameContainer">
        <div class="game-controls">
            <button class="game-control-button admin" onclick="showAdminStats()">Admin</button>
            <button class="game-control-button exit" onclick="saveAndExit()">Exit</button>
        </div>
        <div class="profile-name-display" id="profileNameDisplay"></div>
        <div class="quiz-section" id="quizSection">
            <div class="score">Score: <span id="score">0</span></div>
            <div class="question" id="question"></div>
            <div class="options" id="options"></div>
        </div>
        <button class="building-toggle" id="buildingToggle">Show Building Area</button>
        <div class="building-section" id="buildingArea">
            <div class="inventory-selector" id="inventorySelector"></div>
        </div>
        <!-- Add Mobile Controls -->
        <div class="mobile-controls">
            <div class="mobile-controls-grid">
                <div class="mobile-control-button" data-action="up">↑</div>
                <div class="mobile-control-button" data-action="left">←</div>
                <div class="mobile-control-button" data-action="right">→</div>
                <div class="mobile-control-button" data-action="down">↓</div>
            </div>
            <div class="mobile-action-buttons">
                <div class="mobile-control-button" data-action="mine">Mine</div>
                <div class="mobile-control-button" data-action="place">Place</div>
                <div class="mobile-control-button" data-action="inventory">Inv</div>
            </div>
        </div>
    </div>

    <div class="profile-container" id="profileContainer">
        <h2>Select or Create a Profile</h2>
        <div class="profile-list" id="profileList"></div>
        <div class="new-profile-form">
            <input type="text" id="newProfileName" placeholder="Enter profile name" maxlength="20">
            <button onclick="createNewProfile()">Create New Profile</button>
        </div>
    </div>

    <div id="adminStats"
        style="display: none; background:rgba(0, 0, 0, 0.9); color:#fff; padding:20px; border-radius:10px; max-width:90vw; max-height:80vh; position:fixed; top:50px; left:50%; transform:translateX(-50%); z-index:2000; font-family: 'VT323', monospace; flex-direction: column;">
        <div style="position: sticky; top: 0; background: rgba(0, 0, 0, 0.9); padding-bottom: 10px; border-bottom: 2px solid #ffd700; margin-bottom: 10px; z-index: 1;">
            <h2 style="color: #ffd700; text-shadow: 2px 2px #3f3f3f; margin: 0;" id="adminStatsTitle">Admin Stats</h2>
        </div>
        <div style="overflow-y: auto; flex: 1; padding-right: 10px;">
            <!-- Content will be inserted here -->
        </div>
        <button onclick="document.getElementById('adminStats').style.display='none'" 
            style="position: sticky; bottom: 0; background-color: rgba(255, 193, 7, 0.7); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-family: 'VT323', monospace; font-size: 1.1em; margin-top: 10px; width: 100%;">
            Close
        </button>
    </div>

    <script src="version.js"></script>
    <script>
        // Block textures
        const blockTextures = {
            dirt: {
                backgroundColor: 'rgb(139, 69, 19)',
                backgroundImage: 'linear-gradient(45deg, rgb(139, 69, 19) 25%, rgb(160, 82, 45) 25%, rgb(160, 82, 45) 50%, rgb(139, 69, 19) 50%, rgb(139, 69, 19) 75%, rgb(160, 82, 45) 75%, rgb(160, 82, 45) 100%)',
                backgroundSize: '8px 8px'
            },
            stone: {
                backgroundColor: 'rgb(128, 128, 128)',
                backgroundImage: 'linear-gradient(45deg, rgb(128, 128, 128) 25%, rgb(105, 105, 105) 25%, rgb(105, 105, 105) 50%, rgb(128, 128, 128) 50%, rgb(128, 128, 128) 75%, rgb(105, 105, 105) 75%, rgb(105, 105, 105) 100%)',
                backgroundSize: '8px 8px'
            },
            wood: {
                backgroundColor: 'rgb(160, 82, 45)',
                backgroundImage: 'linear-gradient(90deg, rgb(160, 82, 45) 25%, rgb(139, 69, 19) 25%, rgb(139, 69, 19) 50%, rgb(160, 82, 45) 50%, rgb(160, 82, 45) 75%, rgb(139, 69, 19) 75%, rgb(139, 69, 19) 100%)',
                backgroundSize: '8px 8px'
            },
            glass: {
                backgroundColor: 'rgb(173, 216, 230)',
                backgroundImage: 'linear-gradient(45deg, rgb(173, 216, 230) 25%, rgb(135, 206, 235) 25%, rgb(135, 206, 235) 50%, rgb(173, 216, 230) 50%, rgb(173, 216, 230) 75%, rgb(135, 206, 235) 75%, rgb(135, 206, 235) 100%)',
                backgroundSize: '8px 8px',
                opacity: '0.7'
            }
        };

        // Get block style
        function getBlockStyle(type) {
            return blockTextures[type] || blockTextures.dirt;
        }

        // Profile Management
        class ProfileManager {
            constructor() {
                console.log('Initializing ProfileManager');
                this.profiles = {};
                this.currentProfile = null;
                this.db = null;
                this.auth = null;
                this.isOnline = navigator.onLine;
                this.syncQueue = [];
                this.initFirebase();
                this.setupNetworkListeners();
            }

            logOperation(operation, details) {
                const timestamp = new Date().toISOString();
                const logEntry = {
                    timestamp,
                    operation,
                    details,
                    online: this.isOnline,
                    currentProfile: this.currentProfile,
                    queueLength: this.syncQueue.length
                };
                console.log('Firebase Operation:', logEntry);
                
                // Store logs in localStorage for persistence
                const logs = JSON.parse(localStorage.getItem('firebase_logs') || '[]');
                logs.push(logEntry);
                // Keep only last 100 logs
                if (logs.length > 100) logs.shift();
                localStorage.setItem('firebase_logs', JSON.stringify(logs));
            }

            loadFromLocalStorage() {
                const profiles = localStorage.getItem('vocabcraft_profiles');
                const parsedProfiles = profiles ? JSON.parse(profiles) : {};
                this.logOperation('load_local_storage', {
                    foundProfiles: Object.keys(parsedProfiles).length,
                    profileIds: Object.keys(parsedProfiles),
                    profileNames: Object.values(parsedProfiles).map(p => p.name)
                });
                return parsedProfiles;
            }

            saveToLocalStorage() {
                this.logOperation('save_local_storage', {
                    savingProfiles: Object.keys(this.profiles).length,
                    profileIds: Object.keys(this.profiles),
                    profileNames: Object.values(this.profiles).map(p => p.name)
                });
                localStorage.setItem('vocabcraft_profiles', JSON.stringify(this.profiles));
            }

            async initFirebase() {
                this.logOperation('init', 'Starting Firebase initialization');
                try {
                    const firebaseConfig = {
                        apiKey: "AIzaSyCSZUNwL45dj49Nq-NPD5aAJDi7ooxUxnk",
                        authDomain: "vocabcraft-81563.firebaseapp.com",
                        projectId: "vocabcraft-81563",
                        storageBucket: "vocabcraft-81563.firebasestorage.app",
                        messagingSenderId: "238507816169",
                        appId: "1:238507816169:web:ecdcdce8634db70c53ac78"
                    };

                    firebase.initializeApp(firebaseConfig);
                    this.db = firebase.firestore();
                    this.auth = firebase.auth();
                    
                    this.logOperation('init', 'Firebase initialized successfully');
                    
                    // Enable Firestore logging and offline persistence
                    try {
                        await this.db.enablePersistence();
                        this.logOperation('persistence', 'Enabled offline persistence');
                    } catch (err) {
                        this.logOperation('persistence_error', err);
                        console.warn('Offline persistence not available:', err);
                    }

                    // Set up connection state listener
                    this.db.enableNetwork().catch(err => {
                        this.logOperation('network_error', err);
                        console.warn('Network connection failed:', err);
                    });

                    this.db.waitForPendingWrites().then(() => {
                        this.logOperation('pending_writes', 'All pending writes completed');
                    }).catch(err => {
                        this.logOperation('pending_writes_error', err);
                    });

                    // Load profiles and render
                    await this.loadProfiles();
                    this.renderProfileList();
                    this.updateConnectionStatus();
                } catch (error) {
                    this.logOperation('init_error', error);
                    console.error('Firebase initialization error:', error);
                    this.showOfflineMessage();
                }
            }

            showOfflineMessage() {
                const messageDiv = document.createElement('div');
                messageDiv.id = 'offlineMessage';
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 10px;
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: rgba(255, 193, 7, 0.9);
                    color: black;
                    padding: 10px 20px;
                    border-radius: 5px;
                    z-index: 2000;
                    font-family: 'VT323', monospace;
                    font-size: 1.2em;
                    text-align: center;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                `;
                messageDiv.textContent = 'Working in offline mode. Changes will sync when connection is restored.';
                document.body.appendChild(messageDiv);

                // Remove message after 5 seconds
                setTimeout(() => {
                    messageDiv.style.opacity = '0';
                    messageDiv.style.transition = 'opacity 0.5s ease-out';
                    setTimeout(() => messageDiv.remove(), 500);
                }, 5000);
            }

            updateConnectionStatus() {
                if (!this.isOnline) {
                    this.showOfflineMessage();
                }
            }

            setupNetworkListeners() {
                window.addEventListener('online', () => {
                    console.log('Network connection restored');
                    this.isOnline = true;
                    this.logOperation('network_status', 'Online');
                    this.syncWithFirebase();
                    this.updateConnectionStatus();
                });

                window.addEventListener('offline', () => {
                    console.log('Network connection lost');
                    this.isOnline = false;
                    this.logOperation('network_status', 'Offline');
                    this.showOfflineMessage();
                });
            }

            async loadProfiles() {
                this.logOperation('load_start', 'Starting profile load');
                const localProfiles = this.loadFromLocalStorage();
                
                if (this.isOnline) {
                    try {
                        const snapshot = await this.db.collection('profiles').get();
                        const firestoreProfiles = {};
                        snapshot.forEach(doc => {
                            firestoreProfiles[doc.id] = doc.data();
                        });

                        this.logOperation('load_firestore', {
                            profileCount: Object.keys(firestoreProfiles).length,
                            profileIds: Object.keys(firestoreProfiles)
                        });

                        this.profiles = {};
                        
                        // Process Firestore profiles
                        Object.entries(firestoreProfiles).forEach(([id, data]) => {
                            this.profiles[id] = data;
                        });

                        // Process local profiles
                        Object.entries(localProfiles).forEach(([id, localData]) => {
                            if (this.profiles[id]) {
                                const firestoreData = this.profiles[id];
                                if (localData.lastSaved > firestoreData.lastSaved) {
                                    this.logOperation('conflict_resolution', {
                                        profileId: id,
                                        localVersion: localData.version,
                                        firestoreVersion: firestoreData.version,
                                        resolution: 'local_wins'
                                    });
                                    this.syncQueue.push({ type: 'update', id, data: localData });
                                }
                            } else {
                                this.logOperation('new_local_profile', {
                                    profileId: id,
                                    profileName: localData.name
                                });
                                this.syncQueue.push({ type: 'create', id, data: localData });
                            }
                            this.profiles[id] = localData;
                        });

                        await this.syncWithFirebase();
                    } catch (error) {
                        this.logOperation('load_error', error);
                        console.error('Error loading from Firestore:', error);
                        this.profiles = localProfiles;
                        this.showOfflineMessage();
                    }
                } else {
                    this.logOperation('load_offline', {
                        localProfileCount: Object.keys(localProfiles).length
                    });
                    this.profiles = localProfiles;
                    this.showOfflineMessage();
                }
            }

            async syncWithFirebase() {
                if (!this.isOnline) {
                    this.logOperation('sync_skipped', 'Offline - sync skipped');
                    return;
                }

                this.logOperation('sync_start', {
                    queueLength: this.syncQueue.length,
                    operations: this.syncQueue.map(op => op.type)
                });

                try {
                    const batch = this.db.batch();
                    let hasChanges = false;
                    let processedOps = 0;
                    let skippedOps = 0;

                    while (this.syncQueue.length > 0) {
                        const operation = this.syncQueue.shift();
                        const profileRef = this.db.collection('profiles').doc(operation.id);

                        switch (operation.type) {
                            case 'create':
                            case 'update':
                                const doc = await profileRef.get();
                                if (doc.exists) {
                                    const existingData = doc.data();
                                    if (existingData.version > operation.data.version) {
                                        this.logOperation('conflict_detected', {
                                            profileId: operation.id,
                                            operation: operation.type,
                                            localVersion: operation.data.version,
                                            serverVersion: existingData.version,
                                            resolution: 'server_wins'
                                        });
                                        this.profiles[operation.id] = existingData;
                                        this.saveToLocalStorage();
                                        skippedOps++;
                                        continue;
                                    }
                                }
                                batch.set(profileRef, operation.data);
                                hasChanges = true;
                                processedOps++;
                                break;
                            case 'delete':
                                batch.delete(profileRef);
                                hasChanges = true;
                                processedOps++;
                                break;
                        }
                    }

                    if (hasChanges) {
                        await batch.commit();
                        this.logOperation('sync_success', {
                            processedOps,
                            skippedOps,
                            remainingQueue: this.syncQueue.length
                        });
                    } else {
                        this.logOperation('sync_no_changes', {
                            processedOps,
                            skippedOps
                        });
                    }
                } catch (error) {
                    this.logOperation('sync_error', {
                        error: error.message,
                        code: error.code,
                        remainingQueue: this.syncQueue.length
                    });
                    console.error('Error syncing with Firebase:', error);
                    this.syncQueue = [...this.syncQueue, ...this.syncQueue];
                }
            }

            // Add a method to view logs
            showLogs() {
                const logs = JSON.parse(localStorage.getItem('firebase_logs') || '[]');
                console.table(logs);
                return logs;
            }

            // Generate a UUID v4
            generateUUID() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            async createProfile(name) {
                // Check if name already exists
                const existingProfile = Object.values(this.profiles).find(p => p.name === name);
                if (existingProfile) {
                    return false; // Profile name already exists
                }

                const profileId = this.generateUUID();
                const newProfile = {
                    name: name,
                    score: 0,
                    currentQuestion: 0,
                    blockCounts: {
                        dirt: 0,
                        stone: 0,
                        wood: 0,
                        glass: 0
                    },
                    blocks: [],
                    characterPosition: {
                        x: 280,
                        y: 180
                    },
                    lastSaved: new Date().toISOString(),
                    questionStats: {},
                    version: 1 // Add version for conflict detection
                };

                // Save to localStorage
                this.profiles[profileId] = newProfile;
                this.saveToLocalStorage();

                // Queue for Firebase sync
                if (this.isOnline) {
                    this.syncQueue.push({ type: 'create', id: profileId, data: newProfile });
                    await this.syncWithFirebase();
                }

                this.renderProfileList();
                return true;
            }

            async deleteProfile(name) {
                if (confirm(`Are you sure you want to delete profile "${name}"?`)) {
                    // Remove from localStorage
                    delete this.profiles[name];
                    this.saveToLocalStorage();

                    // Queue for Firebase sync
                    if (this.isOnline) {
                        this.syncQueue.push({ type: 'delete', name });
                        await this.syncWithFirebase();
                    }

                    this.renderProfileList();
                }
            }

            loadProfile(name) {
                this.currentProfile = name;
                return this.profiles[name];
            }

            async saveProfile(gameState) {
                if (!this.currentProfile) return;

                const updatedProfile = {
                    ...gameState,
                    lastSaved: new Date().toISOString(),
                    version: (this.profiles[this.currentProfile].version || 0) + 1
                };

                // Save to localStorage
                this.profiles[this.currentProfile] = updatedProfile;
                this.saveToLocalStorage();

                // Queue for Firebase sync
                if (this.isOnline) {
                    this.syncQueue.push({ type: 'update', id: this.currentProfile, data: updatedProfile });
                    await this.syncWithFirebase();
                }
            }

            renderProfileList() {
                const profileList = document.getElementById('profileList');
                if (!profileList) {
                    console.error('Profile list element not found');
                    return;
                }

                profileList.innerHTML = '';

                // Sort profiles by name
                const sortedProfiles = Object.entries(this.profiles)
                    .sort(([, a], [, b]) => a.name.localeCompare(b.name));

                sortedProfiles.forEach(([id, data]) => {
                    const profileItem = document.createElement('div');
                    profileItem.className = 'profile-item';

                    const profileInfo = document.createElement('div');
                    profileInfo.className = 'profile-info';

                    const profileName = document.createElement('div');
                    profileName.className = 'profile-name';
                    profileName.textContent = data.name;

                    const profileStats = document.createElement('div');
                    profileStats.className = 'profile-stats';
                    profileStats.textContent = `Score: ${data.score} | Last saved: ${new Date(data.lastSaved).toLocaleString()}`;

                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'delete-profile';
                    deleteButton.textContent = 'Delete';
                    deleteButton.onclick = (e) => {
                        e.stopPropagation();
                        this.deleteProfile(id);
                    };

                    profileInfo.appendChild(profileName);
                    profileInfo.appendChild(profileStats);
                    profileItem.appendChild(profileInfo);
                    profileItem.appendChild(deleteButton);

                    profileItem.onclick = () => this.startGame(id);
                    profileList.appendChild(profileItem);
                });
            }

            showSaveIndicator() {
                const indicator = document.getElementById('saveIndicator');
                indicator.classList.add('visible');
                setTimeout(() => {
                    indicator.classList.remove('visible');
                }, 2000);
            }

            startGame(profileName) {
                console.log('Starting game for profile:', profileName);
                const gameState = this.loadProfile(profileName);
                if (!gameState) {
                    console.error('No game state found for profile:', profileName);
                    return;
                }

                // Get all required elements
                const profileContainer = document.getElementById('profileContainer');
                const quizSection = document.getElementById('quizSection');
                const inventorySelector = document.getElementById('inventorySelector');
                const buildingArea = document.getElementById('buildingArea');
                const profileNameDisplay = document.getElementById('profileNameDisplay');
                const buildingToggle = document.getElementById('buildingToggle');

                // Verify all required elements exist
                if (!profileContainer || !quizSection || !inventorySelector || !buildingArea || !profileNameDisplay) {
                    console.error('Required UI elements not found');
                    return;
                }

                // Show loading state
                const loadingMessage = document.createElement('div');
                loadingMessage.style.position = 'fixed';
                loadingMessage.style.top = '50%';
                loadingMessage.style.left = '50%';
                loadingMessage.style.transform = 'translate(-50%, -50%)';
                loadingMessage.style.padding = '20px';
                loadingMessage.style.background = 'rgba(0, 0, 0, 0.8)';
                loadingMessage.style.color = 'white';
                loadingMessage.style.borderRadius = '10px';
                loadingMessage.style.zIndex = '9999';
                loadingMessage.textContent = 'Loading vocabulary...';
                document.body.appendChild(loadingMessage);

                // Hide profile UI
                profileContainer.style.display = 'none';

                // Set initial view state
                quizSection.classList.add('visible');
                buildingArea.classList.remove('visible');
                inventorySelector.classList.add('visible');
                buildingToggle.textContent = 'Show Building Area';

                // Clear any existing game state
                this.cleanupGameState();

                // Initialize new game
                console.log('Creating new game instance');
                window.game = new VocabCraft(this, profileName);

                // Remove loading message when vocabulary is loaded
                window.game.loadVocabulary().then(() => {
                    document.body.removeChild(loadingMessage);
                    // Load game state
                    console.log('Loading game state');
                    window.game.loadGame(gameState);
                }).catch(error => {
                    console.error('Error loading vocabulary:', error);
                    loadingMessage.textContent = 'Error loading vocabulary. Please refresh the page.';
                    loadingMessage.style.background = 'rgba(255, 0, 0, 0.8)';
                });
            }

            cleanupGameState() {
                console.log('Cleaning up game state');

                // Get all required elements
                const buildingArea = document.getElementById('buildingArea');
                const quizSection = document.getElementById('quizSection');
                const inventorySelector = document.getElementById('inventorySelector');
                const buildingToggle = document.getElementById('buildingToggle');
                const mobileControls = document.querySelector('.mobile-controls');

                // Reset view states
                if (quizSection) {
                    quizSection.classList.remove('visible');
                }
                if (buildingArea) {
                    buildingArea.innerHTML = '<div class="inventory-selector" id="inventorySelector"></div>';
                    buildingArea.classList.remove('visible');
                }
                if (buildingToggle) {
                    buildingToggle.textContent = 'Show Building Area';
                }
                if (mobileControls) {
                    mobileControls.classList.remove('visible');
                    mobileControls.style.display = 'none';
                }

                // Remove character if exists
                if (window.game && window.game.character && window.game.character.element) {
                    window.game.character.element.remove();
                }

                // Hide inventory
                if (inventorySelector) {
                    inventorySelector.classList.remove('visible');
                }

                // Clear game instance
                window.game = null;
            }

            exitToProfile() {
                if (window.game) {
                    const gameState = window.game.saveGame();
                    this.saveProfile(gameState);
                }

                // Show profile UI
                document.getElementById('profileContainer').style.display = 'block';
                document.getElementById('quizSection').style.display = 'none';
                document.getElementById('inventorySelector').classList.remove('visible');

                // Clean up game state
                this.cleanupGameState();

                // Update profile list
                this.renderProfileList();
            }
        }

        // Game class update
        class VocabCraft {
            constructor(profileManager, profileName) {
                console.log('Initializing VocabCraft with profile:', profileName);
                this.profileManager = profileManager;
                this.profileName = profileName;
                this.vocabulary = [];
                this.currentQuestion = 0;
                this.score = 0;
                this.blocks = [];
                this.blockCounts = {
                    dirt: 0,
                    stone: 0,
                    wood: 0,
                    glass: 0
                };
                this.selectedBlockType = null;

                // Initialize building area toggle
                const buildingToggle = document.getElementById('buildingToggle');
                const buildingArea = document.getElementById('buildingArea');
                const quizSection = document.getElementById('quizSection');
                const mobileControls = document.querySelector('.mobile-controls');
                
                if (buildingToggle && buildingArea && quizSection) {
                    buildingToggle.addEventListener('click', () => {
                        const isBuildingVisible = buildingArea.classList.contains('visible');
                        
                        // Toggle views
                        if (isBuildingVisible) {
                            // Switch to quiz view
                            buildingArea.classList.remove('visible');
                            quizSection.classList.add('visible');
                            buildingToggle.textContent = 'Show Building Area';
                            
                            // Hide mobile controls
                            if (mobileControls) {
                                mobileControls.classList.remove('visible');
                                setTimeout(() => {
                                    mobileControls.style.display = 'none';
                                }, 300);
                            }
                        } else {
                            // Switch to building view
                            quizSection.classList.remove('visible');
                            buildingArea.classList.add('visible');
                            buildingToggle.textContent = 'Show Quiz';
                            
                            // Show mobile controls
                            if (mobileControls) {
                                mobileControls.style.display = 'block';
                                setTimeout(() => {
                                    mobileControls.classList.add('visible');
                                }, 10);
                            }
                        }
                        
                        console.log('View switched:', isBuildingVisible ? 'Quiz' : 'Building');
                    });
                }

                // Load vocabulary before initializing the game
                this.loadVocabulary().then(() => {
                    // Initialize game components
                    this.initGame();
                    this.setupAutoSave();
                });
            }

            async loadVocabulary() {
                try {
                    // Try to load from the same directory first (for local development)
                    const response = await fetch('./vocabulary.json');
                    if (!response.ok) {
                        // If that fails, try loading from the GitHub Pages URL
                        const githubResponse = await fetch('https://justinrao.github.io/vocabcraft/vocabulary.json');
                        if (!githubResponse.ok) {
                            throw new Error('Failed to load vocabulary');
                        }
                        const data = await githubResponse.json();
                        this.vocabulary = data.vocabulary;
                    } else {
                        const data = await response.json();
                        this.vocabulary = data.vocabulary;
                    }
                    console.log('Vocabulary loaded successfully:', this.vocabulary);
                } catch (error) {
                    console.error('Error loading vocabulary:', error);
                    // Fallback to empty vocabulary
                    this.vocabulary = [];
                }
            }

            initGame() {
                console.log('Initializing game components');
                try {
                    // Get all required elements
                    const profileNameDisplay = document.getElementById('profileNameDisplay');
                    const quizSection = document.getElementById('quizSection');
                    const inventorySelector = document.getElementById('inventorySelector');

                    // Verify elements exist
                    if (!profileNameDisplay || !quizSection || !inventorySelector) {
                        throw new Error('Required UI elements not found');
                    }

                    // Set up UI elements
                    profileNameDisplay.textContent = `Profile: ${this.profileName}`;
                    quizSection.style.display = 'block';
                    inventorySelector.style.display = 'flex';

                    // Create character
                    console.log('Creating character');
                    this.character = new Character(this);
                    if (this.character && this.character.element) {
                        this.character.element.style.display = 'block';
                    }

                    // Create inventory
                    console.log('Creating inventory');
                    this.createInventorySelector();

                    // Show first question
                    console.log('Showing first question');
                    this.showQuestion();

                    console.log('Game initialization complete');
                } catch (error) {
                    console.error('Error during game initialization:', error);
                }
            }

            setupAutoSave() {
                // Auto-save every 30 seconds
                setInterval(() => {
                    this.saveGame();
                }, 30000);

                // Save when window is closed
                window.addEventListener('beforeunload', () => {
                    this.saveGame();
                });
            }

            loadGame(gameState) {
                console.log('Loading game state:', gameState);
                if (!gameState) {
                    console.error('No game state provided');
                    return;
                }

                this.score = gameState.score || 0;
                // Use questionId if available, otherwise fallback to index
                if (gameState.currentQuestionId) {
                    const idx = this.vocabulary.findIndex(q => q.id === gameState.currentQuestionId);
                    this.currentQuestion = idx !== -1 ? idx : 0;
                } else {
                    this.currentQuestion = gameState.currentQuestion || 0;
                }
                if (this.currentQuestion >= this.vocabulary.length) {
                    this.currentQuestion = 0;
                }
                // Initialize block counts
                this.blockCounts = {
                    dirt: 0,
                    stone: 0,
                    wood: 0,
                    glass: 0
                };

                // Clear existing blocks
                const buildingArea = document.getElementById('buildingArea');
                this.blocks.forEach(block => {
                    if (block.parentNode === buildingArea) {
                        block.remove();
                    }
                });
                this.blocks = [];

                // Restore blocks and count them
                if (gameState.blocks && gameState.blocks.length > 0) {
                    console.log('Restoring blocks:', gameState.blocks.length);
                    gameState.blocks.forEach(blockData => {
                        const block = document.createElement('div');
                        block.className = 'block';
                        Object.assign(block.style, getBlockStyle(blockData.type));
                        block.style.left = blockData.x + 'px';
                        block.style.top = blockData.y + 'px';
                        buildingArea.appendChild(block);
                        this.blocks.push(block);
                        makeBlockDraggable(block);
                        console.log('Restored block:', blockData);
                    });
                }

                // Restore character position if available
                if (gameState.characterPosition && this.character) {
                    this.character.posX = gameState.characterPosition.x;
                    this.character.posY = gameState.characterPosition.y;
                    this.character.element.style.left = this.character.posX + 'px';
                    this.character.element.style.top = this.character.posY + 'px';
                }

                // Show current question
                this.showQuestion();

                // Update inventory display
                this.createInventorySelector();

                // Ensure building area is visible
                buildingArea.style.display = 'block';
            }

            saveGame() {
                // Calculate current block counts from placed blocks
                const currentBlockCounts = {
                    dirt: 0,
                    stone: 0,
                    wood: 0,
                    glass: 0
                };

                // Count blocks by type
                this.blocks.forEach(block => {
                    const type = this.character.getBlockType(block);
                    currentBlockCounts[type]++;
                });

                // Add any remaining blocks in inventory
                Object.keys(this.blockCounts).forEach(type => {
                    currentBlockCounts[type] += this.blockCounts[type];
                });

                const gameState = {
                    score: this.score,
                    currentQuestionId: this.vocabulary[this.currentQuestion]?.id || null,
                    currentQuestion: this.currentQuestion,
                    blockCounts: currentBlockCounts,
                    blocks: this.blocks.map(block => ({
                        type: this.character.getBlockType(block),
                        x: parseInt(block.style.left),
                        y: parseInt(block.style.top)
                    })),
                    characterPosition: {
                        x: this.character.posX,
                        y: this.character.posY
                    },
                    questionStats: this.profileManager.profiles[this.profileManager.currentProfile]?.questionStats || {}
                };

                console.log('Saving game state:', gameState);
                this.profileManager.saveProfile(gameState);
                return gameState;
            }

            showQuestion() {
                console.log('Showing question:', this.currentQuestion);
                try {
                    const question = this.vocabulary[this.currentQuestion];
                    if (!question) {
                        throw new Error(`No question found for index: ${this.currentQuestion}`);
                    }

                    const questionElement = document.getElementById('question');
                    const optionsContainer = document.getElementById('options');

                    if (!questionElement || !optionsContainer) {
                        throw new Error('Question elements not found');
                    }

                    questionElement.textContent =
                        `What is the meaning of "${question.word}"?\n\nExample: ${question.example}`;

                    optionsContainer.innerHTML = '';

                    // Create a copy of options array and shuffle it
                    const shuffledOptions = [...question.options];
                    for (let i = shuffledOptions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffledOptions[i], shuffledOptions[j]] = [shuffledOptions[j], shuffledOptions[i]];
                    }

                    // Add shuffled options to the container
                    shuffledOptions.forEach((option) => {
                        const button = document.createElement('button');
                        button.className = 'option';
                        button.textContent = option;
                        button.onclick = () => this.checkAnswer(option);
                        optionsContainer.appendChild(button);
                    });

                    console.log('Question displayed successfully');
                } catch (error) {
                    console.error('Error showing question:', error);
                }
            }

            checkAnswer(selectedAnswer) {
                const question = this.vocabulary[this.currentQuestion];
                if (!question) {
                    console.error('No question found for index:', this.currentQuestion);
                    return;
                }
                const optionsContainer = document.getElementById('options');
                const buttons = optionsContainer.getElementsByClassName('option');
                // Track stats
                const profile = this.profileManager.profiles[this.profileManager.currentProfile];
                if (profile) {
                    if (!profile.questionStats) profile.questionStats = {};
                    if (!profile.questionStats[question.id]) profile.questionStats[question.id] = { correct: 0, incorrect: 0 };
                }
                let wasCorrect = false;
                Array.from(buttons).forEach(button => {
                    button.disabled = true;
                    if (button.textContent === selectedAnswer) {
                        if (selectedAnswer === question.meaning) {
                            button.style.backgroundColor = '#4CAF50';
                            this.score += 10;
                            document.getElementById('score').textContent = this.score;
                            this.addBonusBlock();
                            wasCorrect = true;
                        } else {
                            button.style.backgroundColor = '#f44336';
                        }
                    }
                });
                Array.from(buttons).forEach(button => {
                    if (button.textContent === question.meaning) {
                        button.style.backgroundColor = '#4CAF50';
                    }
                });
                // Update stats
                if (profile) {
                    if (wasCorrect) {
                        profile.questionStats[question.id].correct++;
                    } else {
                        profile.questionStats[question.id].incorrect++;
                    }
                    this.profileManager.saveProfile(this.saveGame());
                }
                setTimeout(() => {
                    this.currentQuestion = (this.currentQuestion + 1) % this.vocabulary.length;
                    this.showQuestion();
                }, 1500);
            }

            addBonusBlock() {
                const blockTypes = ['dirt', 'stone', 'wood', 'glass'];
                const randomType = blockTypes[Math.floor(Math.random() * blockTypes.length)];

                // Add block to inventory
                this.blockCounts[randomType]++;

                // Find the count element and animate it
                const selector = document.getElementById('inventorySelector');
                const slot = selector.querySelector(`[data-type="${randomType}"]`);
                if (slot) {
                    const countElement = slot.querySelector('.block-count');
                    if (countElement) {
                        countElement.textContent = this.blockCounts[randomType].toString();
                        countElement.classList.remove('pulse');
                        countElement.offsetHeight; // Trigger reflow
                        countElement.classList.add('pulse');
                    }
                }

                // Update all slot appearances
                this.updateBlockCounts();
            }

            createInventorySelector() {
                console.log('Creating inventory selector...');
                const selector = document.getElementById('inventorySelector');
                if (!selector) {
                    console.error('Inventory selector element not found!');
                    return;
                }
                selector.innerHTML = '';
                console.log('Current block counts:', this.blockCounts);

                const blockTypes = [
                    { type: 'dirt', name: 'Dirt' },
                    { type: 'stone', name: 'Stone' },
                    { type: 'wood', name: 'Wood' },
                    { type: 'glass', name: 'Glass' }
                ];

                blockTypes.forEach(blockInfo => {
                    const slot = document.createElement('div');
                    slot.className = 'inventory-slot';
                    slot.dataset.type = blockInfo.type;
                    Object.assign(slot.style, getBlockStyle(blockInfo.type));

                    const count = document.createElement('div');
                    count.className = 'block-count';
                    const currentCount = this.blockCounts[blockInfo.type] || 0;
                    console.log(`Creating slot for ${blockInfo.type} with count:`, currentCount);
                    count.textContent = currentCount.toString();

                    const name = document.createElement('div');
                    name.className = 'block-name';
                    name.textContent = blockInfo.name;

                    slot.appendChild(count);
                    slot.appendChild(name);
                    selector.appendChild(slot);

                    // Update slot appearance based on count
                    this.updateSlotAppearance(slot, blockInfo.type);

                    slot.addEventListener('click', () => {
                        if (this.blockCounts[blockInfo.type] > 0) {
                            this.selectBlock(slot);
                        }
                    });
                });

                // Select first available block by default
                this.selectFirstAvailableBlock();
                console.log('Inventory selector created with slots');
            }

            selectFirstAvailableBlock() {
                const selector = document.getElementById('inventorySelector');
                const slots = selector.querySelectorAll('.inventory-slot');
                
                // Find first available block
                const availableSlot = Array.from(slots).find(slot => 
                    this.blockCounts[slot.dataset.type] > 0
                );

                if (availableSlot) {
                    this.selectBlock(availableSlot);
                } else {
                    // If no blocks available, deselect all
                    this.selectedBlockType = null;
                    slots.forEach(slot => slot.classList.remove('selected'));
                }
            }

            selectBlock(slot) {
                const selector = document.getElementById('inventorySelector');
                selector.querySelectorAll('.inventory-slot').forEach(s => {
                    s.classList.remove('selected');
                });
                slot.classList.add('selected');
                this.selectedBlockType = slot.dataset.type;
            }

            updateSlotAppearance(slot, type) {
                const count = this.blockCounts[type] || 0;
                console.log(`Updating appearance for ${type}, count:`, count);
                const countElement = slot.querySelector('.block-count');
                if (countElement) {
                    console.log(`Found count element for ${type}, updating to:`, count);
                    countElement.textContent = count.toString();
                } else {
                    console.log(`No count element found for ${type}`);
                }

                if (count === 0) {
                    slot.classList.add('empty');
                    // If this was the selected block, select another available one
                    if (this.selectedBlockType === type) {
                        this.selectFirstAvailableBlock();
                    }
                } else {
                    slot.classList.remove('empty');
                }
            }

            updateBlockCounts() {
                console.log('Updating all block counts:', this.blockCounts);
                const selector = document.getElementById('inventorySelector');
                if (selector) {
                    selector.querySelectorAll('.inventory-slot').forEach(slot => {
                        const type = slot.dataset.type;
                        this.updateSlotAppearance(slot, type);
                    });
                } else {
                    console.log('Inventory selector not found');
                }
            }

            placeBlock(x, y) {
                if (this.selectedBlockType && this.blockCounts[this.selectedBlockType] > 0) {
                    const block = document.createElement('div');
                    block.className = 'block';
                    Object.assign(block.style, getBlockStyle(this.selectedBlockType));

                    const gridX = Math.floor(x / 40) * 40;
                    const gridY = Math.floor(y / 40) * 40;

                    block.style.left = gridX + 'px';
                    block.style.top = gridY + 'px';

                    const isOccupied = this.blocks.some(existingBlock => {
                        const existingX = parseInt(existingBlock.style.left);
                        const existingY = parseInt(existingBlock.style.top);
                        return existingX === gridX && existingY === gridY;
                    });

                    if (!isOccupied) {
                        document.getElementById('buildingArea').appendChild(block);
                        this.blocks.push(block);
                        this.blockCounts[this.selectedBlockType]--;
                        this.updateBlockCounts();
                        makeBlockDraggable(block);

                        block.style.opacity = '0';
                        block.style.transform = 'scale(0.5)';
                        requestAnimationFrame(() => {
                            block.style.transition = 'all 0.3s ease-out';
                            block.style.opacity = '1';
                            block.style.transform = 'scale(1)';
                        });

                        // Save state after placing block
                        this.saveGame();
                    }
                }
            }

            addBlock(type) {
                console.log(`Adding block of type ${type}, current count:`, this.blockCounts[type]);
                if (this.blockCounts[type] !== undefined) {
                    this.blockCounts[type]++;
                    console.log(`New count for ${type}:`, this.blockCounts[type]);
                    this.updateBlockCounts();
                    
                    // If this is the first block of this type, select it
                    if (this.blockCounts[type] === 1) {
                        const selector = document.getElementById('inventorySelector');
                        const slot = selector.querySelector(`[data-type="${type}"]`);
                        if (slot) {
                            this.selectBlock(slot);
                        }
                    }
                }
            }
        }

        // Character class to manage the player character
        class Character {
            constructor(game) {
                this.game = game;
                this.element = this.createCharacter();
                this.posX = 280;
                this.posY = 180;
                this.speed = 40;
                this.initControls();

                // Set initial position immediately
                this.element.style.left = this.posX + 'px';
                this.element.style.top = this.posY + 'px';
            }

            createCharacter() {
                const character = document.createElement('div');
                character.className = 'character';

                const head = document.createElement('div');
                head.className = 'character-head';

                const body = document.createElement('div');
                body.className = 'character-body';

                const leftArm = document.createElement('div');
                leftArm.className = 'character-arm left';

                const rightArm = document.createElement('div');
                rightArm.className = 'character-arm right';

                const leftLeg = document.createElement('div');
                leftLeg.className = 'character-leg left';

                const rightLeg = document.createElement('div');
                rightLeg.className = 'character-leg right';

                const bag = document.createElement('div');
                bag.className = 'character-bag';

                character.appendChild(head);
                character.appendChild(body);
                character.appendChild(leftArm);
                character.appendChild(rightArm);
                character.appendChild(leftLeg);
                character.appendChild(rightLeg);
                character.appendChild(bag);

                character.style.left = this.posX + 'px';
                character.style.top = this.posY + 'px';
                document.getElementById('buildingArea').appendChild(character);

                return character;
            }

            initControls() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        this.mineBlock();
                        return;
                    }

                    // Inventory controls
                    if (e.key.toLowerCase() === 'a') {
                        this.selectPreviousBlock();
                        return;
                    }
                    if (e.key.toLowerCase() === 's') {
                        this.selectNextBlock();
                        return;
                    }
                    if (e.key.toLowerCase() === 'd') {
                        this.placeBlockInFront();
                        return;
                    }

                    let newX = this.posX;
                    let newY = this.posY;
                    let direction = '';

                    switch (e.key) {
                        case 'ArrowLeft':
                            newX = Math.max(0, this.posX - this.speed);
                            direction = 'left';
                            break;
                        case 'ArrowRight':
                            newX = Math.min(document.getElementById('buildingArea').clientWidth - 40, this.posX + this.speed);
                            direction = 'right';
                            break;
                        case 'ArrowUp':
                            newY = Math.max(0, this.posY - this.speed);
                            direction = 'back';
                            break;
                        case 'ArrowDown':
                            newY = Math.min(document.getElementById('buildingArea').clientHeight - 40, this.posY + this.speed);
                            direction = 'front';
                            break;
                    }

                    if (!this.willCollide(newX, newY)) {
                        this.posX = newX;
                        this.posY = newY;
                        this.element.style.left = this.posX + 'px';
                        this.element.style.top = this.posY + 'px';

                        // Update facing direction
                        this.element.className = 'character';
                        if (direction) {
                            this.element.classList.add('facing-' + direction);
                        }
                    }
                });

                // Touch controls
                const mobileControls = document.querySelector('.mobile-controls');
                if (mobileControls) {
                    mobileControls.addEventListener('touchstart', (e) => {
                        const button = e.target.closest('.mobile-control-button');
                        if (!button) return;

                        e.preventDefault();
                        const action = button.dataset.action;

                        switch (action) {
                            case 'up':
                                this.moveCharacter(0, -this.speed, 'back');
                                break;
                            case 'down':
                                this.moveCharacter(0, this.speed, 'front');
                                break;
                            case 'left':
                                this.moveCharacter(-this.speed, 0, 'left');
                                break;
                            case 'right':
                                this.moveCharacter(this.speed, 0, 'right');
                                break;
                            case 'mine':
                                this.mineBlock();
                                break;
                            case 'place':
                                this.placeBlockInFront();
                                break;
                            case 'inventory':
                                this.selectNextBlock();
                                break;
                        }
                    });
                }
            }

            moveCharacter(deltaX, deltaY, direction) {
                const newX = Math.max(0, Math.min(document.getElementById('buildingArea').clientWidth - 40, this.posX + deltaX));
                const newY = Math.max(0, Math.min(document.getElementById('buildingArea').clientHeight - 40, this.posY + deltaY));

                if (!this.willCollide(newX, newY)) {
                    this.posX = newX;
                    this.posY = newY;
                    this.element.style.left = this.posX + 'px';
                    this.element.style.top = this.posY + 'px';

                    // Update facing direction
                    this.element.className = 'character';
                    if (direction) {
                        this.element.classList.add('facing-' + direction);
                    }
                }
            }

            selectPreviousBlock() {
                const selector = document.getElementById('inventorySelector');
                const slots = selector.querySelectorAll('.inventory-slot');
                const currentIndex = Array.from(slots).findIndex(slot => slot.classList.contains('selected'));

                let newIndex = currentIndex - 1;
                if (newIndex < 0) newIndex = slots.length - 1;

                // Find the first non-empty slot going backwards
                while (newIndex !== currentIndex) {
                    const slot = slots[newIndex];
                    const type = slot.dataset.type;
                    if (this.game.blockCounts[type] > 0) {
                        this.selectBlock(slot);
                        break;
                    }
                    newIndex = (newIndex - 1 + slots.length) % slots.length;
                }
            }

            selectNextBlock() {
                const selector = document.getElementById('inventorySelector');
                const slots = selector.querySelectorAll('.inventory-slot');
                const currentIndex = Array.from(slots).findIndex(slot => slot.classList.contains('selected'));

                let newIndex = (currentIndex + 1) % slots.length;

                // Find the first non-empty slot going forwards
                while (newIndex !== currentIndex) {
                    const slot = slots[newIndex];
                    const type = slot.dataset.type;
                    if (this.game.blockCounts[type] > 0) {
                        this.selectBlock(slot);
                        break;
                    }
                    newIndex = (newIndex + 1) % slots.length;
                }
            }

            selectBlock(slot) {
                const selector = document.getElementById('inventorySelector');
                selector.querySelectorAll('.inventory-slot').forEach(s => {
                    s.classList.remove('selected');
                });
                slot.classList.add('selected');
                this.game.selectedBlockType = slot.dataset.type;
            }

            placeBlockInFront() {
                if (!this.game.selectedBlockType || this.game.blockCounts[this.game.selectedBlockType] <= 0) {
                    return;
                }

                // Calculate position in front of character based on facing direction
                let placeX = this.posX;
                let placeY = this.posY;

                // Determine placement position based on character's facing direction
                if (this.element.classList.contains('facing-left')) {
                    placeX -= 40;
                } else if (this.element.classList.contains('facing-right')) {
                    placeX += 40;
                } else if (this.element.classList.contains('facing-back')) {
                    placeY -= 40;
                } else { // facing front (default)
                    placeY += 40;
                }

                // Snap to grid
                placeX = Math.floor(placeX / 40) * 40;
                placeY = Math.floor(placeY / 40) * 40;

                // Check if position is within bounds
                const buildingArea = document.getElementById('buildingArea');
                if (placeX < 0 || placeX > buildingArea.clientWidth - 40 ||
                    placeY < 0 || placeY > buildingArea.clientHeight - 40) {
                    return;
                }

                // Check if position is already occupied
                const isOccupied = this.game.blocks.some(block => {
                    const blockX = parseInt(block.style.left);
                    const blockY = parseInt(block.style.top);
                    return blockX === placeX && blockY === placeY;
                });

                if (!isOccupied) {
                    const block = document.createElement('div');
                    block.className = 'block';
                    Object.assign(block.style, getBlockStyle(this.game.selectedBlockType));
                    block.style.left = placeX + 'px';
                    block.style.top = placeY + 'px';

                    buildingArea.appendChild(block);
                    this.game.blocks.push(block);
                    this.game.blockCounts[this.game.selectedBlockType]--;
                    this.game.updateBlockCounts();
                    makeBlockDraggable(block);

                    // Add placement animation
                    block.style.opacity = '0';
                    block.style.transform = 'scale(0.5)';
                    requestAnimationFrame(() => {
                        block.style.transition = 'all 0.3s ease-out';
                        block.style.opacity = '1';
                        block.style.transform = 'scale(1)';
                    });
                }
            }

            willCollide(newX, newY) {
                return this.game.blocks.some(block => {
                    const blockX = parseInt(block.style.left);
                    const blockY = parseInt(block.style.top);
                    return Math.abs(blockX - newX) < 40 && Math.abs(blockY - newY) < 40;
                });
            }

            isOnBlock() {
                const characterCenterX = this.posX + 20;
                const characterCenterY = this.posY + 20;

                return this.game.blocks.some(block => {
                    const blockX = parseInt(block.style.left);
                    const blockY = parseInt(block.style.top);
                    const blockCenterX = blockX + 20;
                    const blockCenterY = blockY + 20;

                    const distanceX = Math.abs(characterCenterX - blockCenterX);
                    const distanceY = Math.abs(characterCenterY - blockCenterY);

                    return distanceX <= 60 && distanceY <= 60;
                });
            }

            getBlockType(block) {
                // Get the computed style of the block
                const style = window.getComputedStyle(block);
                const backgroundColor = style.backgroundColor;

                // Convert RGB colors to comparable format
                const normalizeColor = (color) => {
                    // Convert rgb(r, g, b) to rgb(r,g,b)
                    return color.replace(/\s/g, '').toLowerCase();
                };

                const normalizedBgColor = normalizeColor(backgroundColor);

                // Define color mappings for each block type
                const colorMappings = {
                    'rgb(139,69,19)': 'dirt',      // #8B4513
                    'rgb(128,128,128)': 'stone',   // #808080
                    'rgb(160,82,45)': 'wood',      // #A0522D
                    'rgb(173,216,230)': 'glass'    // #ADD8E6
                };

                // Check if the color matches any of our known block types
                for (const [color, type] of Object.entries(colorMappings)) {
                    if (normalizeColor(color) === normalizedBgColor) {
                        return type;
                    }
                }

                // If no match found, try to determine by background image
                const backgroundImage = style.backgroundImage;
                if (backgroundImage.includes('linear-gradient')) {
                    if (backgroundImage.includes('45deg')) {
                        if (backgroundImage.includes('173,216,230')) return 'glass';
                        if (backgroundImage.includes('139,69,19')) return 'dirt';
                        if (backgroundImage.includes('128,128,128')) return 'stone';
                    } else if (backgroundImage.includes('90deg')) {
                        return 'wood';
                    }
                }

                return 'dirt'; // Default to dirt if type can't be determined
            }

            mineBlock() {
                if (!this.isOnBlock()) return;

                const characterCenterX = this.posX + 20;
                const characterCenterY = this.posY + 20;

                let closestBlock = null;
                let minDistance = Infinity;

                this.game.blocks.forEach(block => {
                    if (block.closest('.block-palette')) return;

                    const blockX = parseInt(block.style.left);
                    const blockY = parseInt(block.style.top);
                    const blockCenterX = blockX + 20;
                    const blockCenterY = blockY + 20;

                    const distanceX = Math.abs(characterCenterX - blockCenterX);
                    const distanceY = Math.abs(characterCenterY - blockCenterY);
                    const totalDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

                    if (totalDistance < minDistance && distanceX <= 60 && distanceY <= 60) {
                        minDistance = totalDistance;
                        closestBlock = block;
                    }
                });

                if (closestBlock) {
                    const blockType = this.getBlockType(closestBlock);
                    closestBlock.classList.add('mining');
                    closestBlock.style.animation = 'mining 0.5s ease-in-out';

                    setTimeout(() => {
                        if (closestBlock.parentNode) {
                            closestBlock.remove();
                            this.game.blocks = this.game.blocks.filter(b => b !== closestBlock);
                            this.game.addBlock(blockType);
                            
                            // Save state after mining block
                            this.game.saveGame();
                        }
                    }, 500);
                }
            }

            addBlock() {
                const block = document.createElement('div');
                block.className = 'block';

                const blockTypes = ['dirt', 'stone', 'wood', 'glass'];
                const randomType = blockTypes[Math.floor(Math.random() * blockTypes.length)];
                Object.assign(block.style, getBlockStyle(randomType));

                const buildingArea = document.getElementById('buildingArea');
                const areaWidth = buildingArea.clientWidth - 40;
                const areaHeight = buildingArea.clientHeight - 40;

                let attempts = 0;
                let position;
                let isOverlapping;

                do {
                    const x = Math.floor(Math.random() * (areaWidth / 40)) * 40;
                    const y = Math.floor(Math.random() * (areaHeight / 40)) * 40;
                    position = { x, y };

                    isOverlapping = this.game.blocks.some(existingBlock => {
                        const existingX = parseInt(existingBlock.style.left);
                        const existingY = parseInt(existingBlock.style.top);
                        return existingX === x && existingY === y;
                    });

                    attempts++;
                } while (isOverlapping && attempts < 50);

                if (isOverlapping) {
                    position = {
                        x: Math.floor((areaWidth - 40) / 80) * 40,
                        y: Math.floor((areaHeight - 40) / 80) * 40
                    };
                }

                block.style.left = position.x + 'px';
                block.style.top = position.y + 'px';

                buildingArea.appendChild(block);
                this.game.blocks.push(block);
                makeBlockDraggable(block);

                block.style.opacity = '0';
                block.style.transform = 'scale(0.5)';

                requestAnimationFrame(() => {
                    block.style.transition = 'all 0.3s ease-out';
                    block.style.opacity = '1';
                    block.style.transform = 'scale(1)';
                });
            }
        }

        // Make block draggable
        function makeBlockDraggable(block) {
            let isDragging = false;
            let mouseOffsetX = 0;
            let mouseOffsetY = 0;

            block.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);

            function dragStart(e) {
                if (e.target === block) {
                    e.preventDefault(); // Prevent text selection
                    isDragging = true;
                    block.style.zIndex = '1000';
                    block.style.transition = 'none';

                    // Calculate mouse offset within the block
                    const blockRect = block.getBoundingClientRect();
                    mouseOffsetX = e.clientX - blockRect.left;
                    mouseOffsetY = e.clientY - blockRect.top;

                    console.log('Drag Start:', {
                        mouseX: e.clientX,
                        mouseY: e.clientY,
                        blockLeft: blockRect.left,
                        blockTop: blockRect.top,
                        offsetX: mouseOffsetX,
                        offsetY: mouseOffsetY
                    });
                }
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault(); // Prevent text selection

                    const buildingArea = document.getElementById('buildingArea');
                    const areaRect = buildingArea.getBoundingClientRect();

                    // Calculate position based on mouse position minus the initial offset
                    let newX = e.clientX - mouseOffsetX - areaRect.left;
                    let newY = e.clientY - mouseOffsetY - areaRect.top;

                    // Snap to grid
                    newX = Math.floor(newX / 40) * 40;
                    newY = Math.floor(newY / 40) * 40;

                    // Check bounds
                    newX = Math.max(0, Math.min(newX, buildingArea.clientWidth - 40));
                    newY = Math.max(0, Math.min(newY, buildingArea.clientHeight - 40));

                    console.log('Dragging:', {
                        mouseX: e.clientX,
                        mouseY: e.clientY,
                        newX: newX,
                        newY: newY,
                        offsetX: mouseOffsetX,
                        offsetY: mouseOffsetY
                    });

                    block.style.left = newX + 'px';
                    block.style.top = newY + 'px';
                }
            }

            function dragEnd(e) {
                if (!isDragging) return;

                e.preventDefault(); // Prevent text selection
                isDragging = false;
                block.style.zIndex = '1';
                block.style.transition = 'all 0.3s ease-out';

                const buildingArea = document.getElementById('buildingArea');
                const areaRect = buildingArea.getBoundingClientRect();

                // Calculate final position based on mouse position minus the initial offset
                let finalX = e.clientX - mouseOffsetX - areaRect.left;
                let finalY = e.clientY - mouseOffsetY - areaRect.top;

                // Snap to grid
                finalX = Math.floor(finalX / 40) * 40;
                finalY = Math.floor(finalY / 40) * 40;

                // Check bounds
                finalX = Math.max(0, Math.min(finalX, buildingArea.clientWidth - 40));
                finalY = Math.max(0, Math.min(finalY, buildingArea.clientHeight - 40));

                console.log('Drag End:', {
                    mouseX: e.clientX,
                    mouseY: e.clientY,
                    finalX: finalX,
                    finalY: finalY,
                    offsetX: mouseOffsetX,
                    offsetY: mouseOffsetY
                });

                block.style.left = finalX + 'px';
                block.style.top = finalY + 'px';
            }
        }

        // Profile functions
        async function createNewProfile() {
            const nameInput = document.getElementById('newProfileName');
            const name = nameInput.value.trim();

            if (name) {
                if (await profileManager.createProfile(name)) {
                    nameInput.value = '';
                    startGame(name);
                } else {
                    alert('A profile with this name already exists!');
                }
            } else {
                alert('Please enter a profile name!');
            }
        }

        async function startGame(profileName) {
            if (profileManager) {
                await profileManager.startGame(profileName);
            }
        }

        async function saveAndExit() {
            if (profileManager) {
                await profileManager.exitToProfile();
            }
        }

        // Initialize profile manager and keyboard navigation
        const profileManager = new ProfileManager();
        initProfileKeyboardNav();

        async function showAdminStats() {
            const statsDiv = document.getElementById('adminStats');
            if (!statsDiv) return;
            
            const currentProfile = profileManager.currentProfile;
            if (!currentProfile) {
                alert('Please select a profile first!');
                return;
            }

            // Refresh profile data from Firestore
            await profileManager.loadProfiles();
            const profileData = profileManager.profiles[currentProfile];
            const contentDiv = statsDiv.querySelector('div:nth-child(2)');
            const titleElement = document.getElementById('adminStatsTitle');
            
            // Update the title with profile name
            titleElement.textContent = `Stats for ${currentProfile}`;
            
            let html = '';
            
            // Group questions by prefix
            const groupedQuestions = {};
            window.game.vocabulary.forEach(q => {
                const prefix = q.id.split('-')[0];
                if (!groupedQuestions[prefix]) {
                    groupedQuestions[prefix] = [];
                }
                groupedQuestions[prefix].push(q);
            });

            // Sort prefixes with proper lesson number handling
            const sortedPrefixes = Object.keys(groupedQuestions).sort((a, b) => {
                // If both are ww4l prefixes, sort by lesson number
                if (a.startsWith('ww4l') && b.startsWith('ww4l')) {
                    const numA = parseInt(a.substring(4));
                    const numB = parseInt(b.substring(4));
                    return numA - numB;
                }
                // Otherwise, sort alphabetically
                return a.localeCompare(b);
            });

            // Create table for each group
            sortedPrefixes.forEach(prefix => {
                // Format the prefix for display
                let displayPrefix = prefix;
                if (prefix.startsWith('ww4l')) {
                    const lessonNum = prefix.substring(4);
                    displayPrefix = `ww4 lesson${lessonNum.padStart(2, '0')}`;
                }
                
                html += `<h3 style="color: #ffd700; margin-top: 20px;">${displayPrefix}</h3>`;
                html += '<table border="1" cellpadding="4" style="border-collapse:collapse; margin-bottom:20px; width:100%; color:#fff;">';
                html += '<tr style="background-color: rgba(255, 193, 7, 0.3);"><th>Word</th><th>Meaning</th><th>Correct</th><th>Incorrect</th><th>Success Rate</th></tr>';
                
                // Sort questions within group by their number
                const sortedQuestions = groupedQuestions[prefix].sort((a, b) => {
                    const numA = parseInt(a.id.split('-')[1]);
                    const numB = parseInt(b.id.split('-')[1]);
                    return numA - numB;
                });

                sortedQuestions.forEach(q => {
                    const stat = (profileData.questionStats && profileData.questionStats[q.id]) || { correct: 0, incorrect: 0 };
                    const total = stat.correct + stat.incorrect;
                    const successRate = total > 0 ? ((stat.correct / total) * 100).toFixed(1) + '%' : 'N/A';
                    
                    // Color coding for success rate
                    let successRateColor = '#fff'; // default white
                    if (total > 0) {
                        const rate = (stat.correct / total) * 100;
                        if (rate >= 70) {
                            successRateColor = '#4CAF50'; // green for good performance
                        } else if (rate < 50) {
                            successRateColor = '#f44336'; // red for poor performance
                        }
                    }
                    
                    html += `<tr>
                        <td>${q.word}</td>
                        <td>${q.meaning}</td>
                        <td>${stat.correct}</td>
                        <td>${stat.incorrect}</td>
                        <td style="color: ${successRateColor}">${successRate}</td>
                    </tr>`;
                });
                html += '</table>';
            });

            contentDiv.innerHTML = html;
            statsDiv.style.display = 'flex';

            // Add ESC key handler
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    statsDiv.style.display = 'none';
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }

        // Ensure admin stats is hidden on page load
        document.addEventListener('DOMContentLoaded', () => {
            const adminStats = document.getElementById('adminStats');
            if (adminStats) {
                adminStats.style.display = 'none';
            }
        });
    </script>
</body>

</html>